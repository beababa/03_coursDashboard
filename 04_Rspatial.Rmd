---
title: "R spatial"
author: "B. Maranget"
date: "20/01/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

# Objet

R spatial avec la librairie sf (traitement des objets géographiques) et mapsf (cartographie)


sources :

- https://r-spatial.github.io/sf/

- https://riatelab.github.io/mapsf/

Ne pas oublier les cheat_sheet

- https://riatelab.github.io/mapsf/articles/web_only/cheat_sheet.html# Objets R spatiaux : le dataframe sf

- https://github.com/rstudio/cheatsheets/blob/main/sf.pdf

# Import


```{r}
library(sf)
zone <- st_read("data/vote.gpkg", "zone")
# quel contenu pour le fichier ?
str(zone)
```


# Indexation

Regarder l'indexation du dataframe dans la partie base R.
Sélectionner le premier bureau et l'afficher.
Quelle est la différence ?


```{r}
zone$numBureau
zone [zone$numBureau == 1,]
zone [1,2]
```


# Operations géométriques

Fusion des bureaux de votes, trouver la fonction et l'appliquer en s'inspirant de l'article 3 du github sf


```{r}
plot(zone$geom)
# première solution
fusion <- st_union(zone)
str(zone)
plot(zone$geom)
# deuxième solution
enveloppe <- st_convex_hull(fusion)
plot(enveloppe)
# troisième solution
tampon <- st_buffer(zone, 50)
plot(tampon$geom)
fusion <- st_union(tampon)
plot(fusion)
simplifier <- st_simplify(fusion,90, preserveTopology = F)
plot(simplifier)
```


# Première carte



```{r}
# carte avec commande rbase
plot(zone$geom, col = terrain.colors (31),
     border = NA,
     main = "31 bureaux de vote de Bondy")
# carte avec mapsf
library(mapsf)
mf_map(zone, type = "choro", border = NA,var = "aire")
# éliminer les bureaux 31 et 32
zone <- zone [zone$numBureau %in% seq(1,30),]
summary(zone)
mf_map(zone, type = "choro", pal = "Burg",
       border = NA, var = "txVotants")
```


# Jointure attributaire


Mettre un lien entre la cartographie et le fichier de résultat des élections

```{r}
data <- read.csv("data/bondyElection.csv", fileEncoding = "UTF-8", dec = ",")
```



## Les clés

```{r}
zone$Layer
data$Bureau.de.vote
```

### Comment recoder pour faire correspondre les clés ?

La clé des zones est de type : _Bureau *Num*
Celle des chiffres est de type : BV*Num*

Il faut donc recoder les valeurs.

Pour faire correspondre les deux clés, il suffit de retirer les lettres et garder uniquement les chiffres.

### Faire l'algo


- pour clé zone, extraire les deux derniers caractères

- pour clé chiffres, extraire à partir du 3e caractère

- vérifier si zone et chiffres correspondent

- supprimer les lignes en trop

- converir les clés en chiffres pour éviter le pb 01

- jointure attributaire zone et chiffres

- sauvegarder le résultat de la jointure

### Donner les fonctions R

- substring

- as.integer

- merge pour le jonction attributaire

### Faire le script

```{r}
data <- data [data$cle[c(1:32)],]
zone$cle <- substring (zone$Layer,9,11)
data$cle <- substring(data$Bureau.de.vote, 3,5 )
data$cle <- as.integer(data$cle)
zone$cle <- as.integer(zone$cle)
length(zone$cle) == length(data$cle)
jointure <- merge(zone, data, by = "cle")
st_write(jointure, "data/vote.gpkg", "jointure", delete_layer = T)
```


# Carte des résultats

```{r}
names(jointure)
```

Cartographier tous les indicateurs (du taux de votant à la liste 5 par une boucle)

(Faire l'algorithme, donner les fonctions, et faire le script)
