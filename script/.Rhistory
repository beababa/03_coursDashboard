layoutLayer(title = "Surface maïs doux", author = "Arvalis 2020", sources = "IGN / Enquêtes AGPM Maïs Semence 2019", horiz = FALSE,
posscale = "bottomleft", theme = "wine.pal")
dev.off()
write.csv(databind, "../dataS/comparaisonMais.csv")
write.csv(databind, "../dataS/comparaisonMais.csv")
write.csv(databind [, drop = TRUE], "../dataS/comparaisonMais.csv")
write.csv(databind [, names(databind)[1:5];drop = TRUE], "../dataS/comparaisonMais.csv")
write.csv(databind [, names(databind)[1:5],drop = TRUE], "../dataS/comparaisonMais.csv")
databind
dataSansGeom <- databind [, c(1:4), drop = TRUE]
knitr::kable(dataSansGeom)
write.csv(dataSansGeom [, names(dataSansGeom)[1:5],drop = TRUE], "../dataS/comparaisonMais.csv")
dataSansGeom <- databind [, c(1:4,6), drop = TRUE]
knitr::kable(dataSansGeom)
write.csv(dataSansGeom [, names(dataSansGeom)[1:5],drop = TRUE], "../dataS/comparaisonMais.csv")
write.csv(dataSansGeom, "../dataS/comparaisonMais.csv")
st_write (databind, "../dataS/rpg.gpkg", "comparaisonMais", delete_layer = TRUE, quiet =TRUE)
mapview(databind)
databind$ratio <- round((databind$`Mais doux (rpg 2019)`/databind$`Mais semence (Questionnaire)`)*100,1)
bks <- getBreaks(v = databind$ratio, nclass = 8, method = "jenks")
hist(databind$ratio, breaks = bks)
breaks <- c(0,25,70,100,250,350,700,1300,1700)
sizes <- getFigDim(x = databind, width = 3000, mar = c(1,1,1.2,1), res = 400)
png("../img/ratio.png", height = sizes [2], width = sizes [1], res = 400)
par(mar = c(1,1,1.2,1))
# marge pour affichage correcte sources
my.pal <- carto.pal(pal1 = "wine.pal", n1 = 3, pal2 = "green.pal", n2 = 5 )
ghostLayer(dataf, bg = "lightblue1")
plot(fond, col = "antiquewhite1", border = "white", add = TRUE)
plot(fondRegion, col = "antiquewhite2", border= "grey",lwd = 1, add = TRUE)
#plot(dataf$geometry, col = "white", border = "grey",add = TRUE)
choroLayer(databind, var = "ratio",
legend.title.txt = "doux / semence (%)", legend.pos = "topright",
breaks = breaks, col = my.pal, nclass = 8 , border = NA, add = TRUE)
layoutLayer(title = "Rapport mais doux et mais semence", author = "Arvalis 2020", sources = "IGN / RPG 2019 / Enquêtes AGPM Maïs Semence 2019", horiz = FALSE,
posscale = "bottomleft", theme = "sand.pal")
dev.off()
databind$ratio <- round((databind$`Mais doux (rpg 2019)`/databind$`Mais semence (Questionnaire)`)*100,1)
bks <- getBreaks(v = databind$ratio, nclass = 8, method = "jenks")
hist(databind$ratio, breaks = bks)
breaks <- c(0,25,70,100,250,350,700,1300,1700)
sizes <- getFigDim(x = databind, width = 3000, mar = c(1,1,1.2,1), res = 400)
png("../img/ratio.png", height = sizes [2], width = sizes [1], res = 400)
par(mar = c(1,1,1.2,1))
# marge pour affichage correcte sources
my.pal <- carto.pal(pal1 = "wine.pal", n1 = 3, pal2 = "green.pal", n2 = 5 )
ghostLayer(databind, bg = "lightblue1")
plot(fond, col = "antiquewhite1", border = "white", add = TRUE)
plot(fondRegion, col = "antiquewhite2", border= "grey",lwd = 1, add = TRUE)
#plot(dataf$geometry, col = "white", border = "grey",add = TRUE)
choroLayer(databind, var = "ratio",
legend.title.txt = "doux / semence (%)", legend.pos = "topright",
breaks = breaks, col = my.pal, nclass = 8 , border = NA, add = TRUE)
layoutLayer(title = "Rapport mais doux et mais semence", author = "Arvalis 2020", sources = "IGN / RPG 2019 / Enquêtes AGPM Maïs Semence 2019", horiz = FALSE,
posscale = "bottomleft", theme = "sand.pal")
dev.off()
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = TRUE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
canton2015 <- st_read("../dataE/00_ADMIN/canton2015/CANTON.SHP")
fond <- st_read("../dataE/00_ADMIN/nuts.gpkg", "pays", quiet = TRUE, stringsAsFactors =F)
rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE)
tab <- addmargins(table(rpg$Code_cultu, rpg$an))
knitr::kable(tab)
# rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE, stringsAsFactors = FALSE)
calcul <- function(data) {
aire <- (sum(st_area(data))/10000)/10000
# résultat en milliers d'ha
moyenne <-(sum(st_area(data)) / nrow(data))/10000
res <- c(aire, moyenne)
}
# liste
lrpg <- split(rpg, rpg$an)
names(lrpg) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
ttsCultures <- sapply(lrpg,calcul)
# uniquement mais 275 234 obs
rpgMais <- rpg [rpg$Code_cultu %in% c("MID", "MIE", "MIS"), ]
st_write(rpgMais, "../dataS/chrysomele.gpkg", "rpgMais", quiet = TRUE, delete_layer = TRUE)
# liste
lrpgMais <- split(rpgMais, rpgMais$an)
names(lrpgMais) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
mais <- sapply(lrpgMais, calcul)
# assemblage et moyenne
total <- rbind(ttsCultures, mais)
moyenne <- apply(total,1, mean)
total <- cbind(total, moyenne)
rownames(total) <-  c("tts total", "tts moy", "mais total", "mais moy")
knitr::kable(total, digits = 1, caption = "Aires moyennes et totales (en milliers ha) toutes cultures et mais - RPG 2019")
alsace <- st_read("../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, stringsAsFactors = FALSE)
rpg <- st_read("../dataS/chrysomele.gpkg", "rpgMais", quiet = TRUE, stringsAsFactors = FALSE)
# 275 324 obs
# agrégation par zones
aggAlsace <- aggregate(alsace [,c("zone"), drop = FALSE], by = list (alsace$zone), length)
names(aggAlsace)[1:2] <- c("groupe", "nb")
# intersection très couteuse. géométrie du rpg nécessite de forcer la validité
inter <- st_intersection(st_make_valid(rpg), aggAlsace)
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = TRUE)
# Nettoyer les géométries, c'est supprimer les geometrycollection
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(dfvalid, "POLYGON")
}
# Fusionner les parcelles adjacentes : union de tous les polygones, puis éclatement
polygoner <- function(df) {
dfunion <- st_union(df)
dfpoly <- st_cast(dfunion, "POLYGON")
}
# Eclater les zones et les années, car on va travailler sur la géométrie.
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
}
# de 207 334 à 207 018
inter <- nettoyerGeom(inter)
summary(inter$geom)
lzone <- split(inter, inter$groupe)
# boucle sur les zones
i <- 1
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
for (i in 1:4){
leclate <- eclater (i)
# lapply  sur les années
lpoly <- lapply(leclate,polygoner)
assign(noms [i], lpoly)
}
# 90 / 27 / 39 et 2 M°
# enregistrement en fichiers pour qgis
enregistrer <- function(df, num) {
#  on récupère le nom de la zone et l'année sur le df même
zone <- substring(deparse(substitute(df)),2,6)
st_write(df, dsn = "../dataS/chrysomelexport.gpkg",
layer = paste0(zone,"_", num), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4){
enregistrer(lzone1 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone2 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone3 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone4 [[i]],i)
}
# pour utiliser lapply, on imbrique les listes de zone dans une liste (cet objet
# est différent du lzone)
limbrique <- list(lzone1, lzone2, lzone3, lzone4)
uniquementCulture <- function(l) {
f <- length (l)
i <- 2
prem <- st_intersection(l[[i-1]], l [[i]])
for (i in 2:(f-1)){
inter <- st_intersection(prem, l[[i+1]])
}
aire <- round(sum(st_area(inter))/10000,2)
return(aire)
}
# test sur petite zone
res <- UniquementCulture(lzone4)
res <-  drop_units(res)
# test sur la liste imbrique
sapply(limbrique,uniquementCulture)
library("units")
lzone4
lunion <- lzone4
X <- lunion [[num]]
num <- 1
X <- lunion [[num]]
lreste <- lunion
lreste [[num]] <- NULL
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]])
Y
res <- st_difference(X,Y)
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]], is_coverage = TRUE)
Y
Y <- st_cast(Y, "POLYGON")
res <- st_difference(X,Y)
X <- st_union(lunion [[num]])
lreste <- lunion
lreste [[num]] <- NULL
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]], is_coverage = TRUE)
Y <- st_cast(Y, "POLYGON")
Y <- st_union(Y)
res <- st_difference(X,Y)
round(st_area(res)/10000,0)
anneeUnique <- function(lunion, num) {
X <- st_union(lunion [[num]])
lreste <- lunion
lreste [[num]] <- NULL
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]], is_coverage = TRUE)
Y <- st_cast(Y, "POLYGON")
Y <- st_union(Y)
res <- st_difference(X,Y)
round(st_area(res)/10000,0)
}
# test sur petite zone
tic()
install.packages("tictoc")
# test sur petite zone
library(tictoc)
tic()
anneeUnique(lzone4,1)
toc()
160/60
# 2 mn pour une zone de 2.4
tic()
anneeUnique(lzone2,1)
toc()
Y <- st_union(lreste [[1]], lreste [[2]],is_coverage = TRUE)
Y <- st_cast(Y, "POLYGON")
Y <- st_union(Y)
Y <- st_union(Y, lreste [[3]] )
Y <- st_cast(Y, "POLYGON")
Y <- st_union(Y)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
library(units) # pour le pb des unités des aires. on supprime.
library(tictoc) # mesure des opérations géométriques st_union
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = TRUE)
# Nettoyer les géométries, c'est supprimer les geometrycollection
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(dfvalid, "POLYGON")
}
# Fusionner les parcelles adjacentes : union de tous les polygones, puis éclatement
polygoner <- function(df) {
dfunion <- st_union(df)
dfpoly <- st_cast(dfunion, "POLYGON")
}
# Eclater les zones et les années, car on va travailler sur la géométrie.
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
}
# de 207 334 à 207 018
inter <- nettoyerGeom(inter)
summary(inter$geom)
lzone <- split(inter, inter$groupe)
# boucle sur les zones
i <- 1
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
for (i in 1:4){
leclate <- eclater (i)
# lapply  sur les années
lpoly <- lapply(leclate,polygoner)
assign(noms [i], lpoly)
}
# 90 / 27 / 39 et 2 M°
# enregistrement en fichiers pour qgis
enregistrer <- function(df, num) {
#  on récupère le nom de la zone et l'année sur le df même
zone <- substring(deparse(substitute(df)),2,6)
st_write(df, dsn = "../dataS/chrysomelexport.gpkg",
layer = paste0(zone,"_", num), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4){
enregistrer(lzone1 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone2 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone3 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone4 [[i]],i)
}
# pour utiliser lapply, on imbrique les listes de zone dans une liste (cet objet
# est différent du lzone)
limbrique <- list(lzone1, lzone2, lzone3, lzone4)
lunion <- lzone2
num <- 1
X <- st_as_sf(st_union(lunion [[num]]))
X
st_crs(X) <- 2154
X
X <- polygoner(X)
X
X <- st_union(X)
X <- st_as_sf(st_union(lunion [[num]]))
st_crs(X) <- 2154
X <- polygoner(X)
X <- st_union(X)
X <- st_make_valid(X)
X <- st_as_sf(st_union(lunion [[num]]))
st_crs(X) <- 2154
X <- polygoner(X)
X <- st_make_valid(X)
X <- st_union(X)
# objet multipolygon
# st_crs(X) lambert 93
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_make_valid(Y)
Y <- st_make_valid(tot)
Y <- st_as_sf(st_union(Y))
Y <- (st_union(Y))
Y <- st_make_valid(Y)
res <- st_difference(X, Y)
lunion <- lzone2
num <- 1
X <- st_as_sf(st_union(lunion [[num]]))
st_crs(X) <- 2154
X <- polygoner(X)
X <- st_union(X)
X <- st_make_valid(X)
X <- st_buffer(X,0)
# objet multipolygon
# st_crs(X) lambert 93
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_make_valid(tot)
Y <- st_buffer(Y,0)
Y <- (st_union(Y))
# sfc
st_crs(Y)
# sfc
st_crs(X)
res <- st_difference(X, Y)
#X <- st_as_sf(st_union(lunion [[num]]))
X <- lunion [[1]]
res <- st_difference(X, Y)
X <- st_buffer(X,0)
Y <- st_buffer(Y,0)
res <- st_difference(X, Y)
df <- zone2
# on repart des enregistrements
for (i in 1:4) {
assign(paste0("zone_",i), st_read ("chrysomelexport.gpkg", paste0("zone2_",i), quiet = TRUE))
}
assign(paste0("zone_",i), st_read ("../dataS/chrysomelexport.gpkg", paste0("zone2_",i), quiet = TRUE))
# on repart des enregistrements
for (i in 1:4) {
assign(paste0("zone_",i), st_read ("../dataS/chrysomelexport.gpkg", paste0("zone2_",i), quiet = TRUE))
}
l <- list(zone_1, zone_2, zone_3, zone_4)
df <- inter [inter$groupe == 2,]
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
Xunion <- st_union(X)
# L'union peut se faire sous R quand même non ?
Y <- (st_union(Y))
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
table(inter$groupe)
noms <- names(table(inter$groupe))
# modification du nom de la 4e zone
table(inter$groupe)
inter$groupe [inter$groupe == "côté Lorrain"] <- 4
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# modification du nom de la 4e zone
table(inter$groupe)
inter$groupe [inter$groupe == "côté Lorrain"] <- 4
# On travaillera à partir de ce fichier désormais.
st_write(inter, "../dataS/chrysomele.gpkg", "inter", quiet = TRUE, delete_layer = TRUE)
# modification du nom de la 4e zone
table(inter$groupe)
# plus simple de repartir d'inter !
df <- inter [inter$groupe == 2,]
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- (st_union(Y))
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
# plus simple de repartir d'inter !
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- st_union(Y)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
#boucle pour les zones
for (i in 1:4) {
assign(paste0("zone",i), inter [inter$groupe == i] )
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(paste0("zone",i), j)
}
}
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i] )
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i,] )
#boucle pour les zones
i <- 1
for (i in 1:4) {
assign(paste0("zone",i), inter [inter$groupe == i,] )
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(paste0("zone",i), j)
}
}
memory.size()
memory.limit(4000)
memory.limit(3000)
memory.limit(2000)
memory.limit(1000)
memory.size()
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i,] )
nom <- paste0("zone",i)
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(nom, j)
}
zone <- deparse(substitute(zone2))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- st_union(Y)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
# plus simple de repartir d'inter !
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- st_union(Y)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
#boucle pour les zones
i <- 1
for (i in 1:4) {
assign(paste0("zone",i), inter [inter$groupe == i,] )
nom <- paste0("zone",i)
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(nom, j)
}
}
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i,] )
nom <- paste0("zone",i)
j <- 1
enregistrerAnneeUnique(nom, j)
