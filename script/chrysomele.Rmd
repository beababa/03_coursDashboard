---
title: "Chrysomele"
author: "B. Maranget"
date: "25/01/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

# Cadre

## Objet

Paramètres à estimer à partir fichiers rpg sur plusieurs années

- taille moyenne parcelles
- SAU moyenne
- surface moyenne mais
- idem mais en ponoculture
- idem mais 1e fois

difficulté : identifiant différent

## Librairies et répertoire

```{r}
library(sf)
library(cartography)
```

## Données

### Générales

```{r}
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
canton2015 <- st_read("../dataE/00_ADMIN/canton2015/CANTON.SHP")
# rpg dezipage
chemin <-"../dataE/01_CULTURES/rpg/"
noms <- list.files(chemin)
for (i in 1:length(noms)){
  unzip(zipfile =  paste0(chemin,noms[i]), exdir = chemin)
}
# assemblage
noms <- list.files(chemin,pattern = ".shp")
data <- NULL
i <- 1
for (i in 1:length(noms)){
  tmp <- st_read(paste0(chemin, noms [i]))
  tmp <- tmp [tmp$Code_cultu %in% c("MID", "MIE", "MIS"), ]
  tmp$an <- substring(noms [i],9,12)
  data <- rbind(data,tmp)
}
# exploration
rpg <- data  [, c("Code_cultu", "an")]
par(mar = c(4,4,4,4))
tab <- table(rpg$Code_cultu, rpg$an)
tab
barplot(tab, beside = T, col = heat.colors(3), border = NA)
# liste
lrpg <- split(rpg, rpg$an)
names(lrpg) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
# Enregistrement en format .gpkg
st_write(rpg, "../dataS/chrysomele.gpkg", "rpg", row.names = FALSE,quiet = TRUE, delete_layer = TRUE)
```

### Zone test

```{r}
test2015 <- rpg2015 [rpg2015$geometry [1],]
bb <- st_as_sfc(st_bbox(test2015))
test2015 <- st_intersection( st_make_valid(rpg2015), bb)
test2016 <- st_intersection( st_make_valid(rpg2015), bb)
test2017 <- st_intersection( st_make_valid(rpg2017), bb)
test2018 <- st_intersection( st_make_valid(rpg2018), bb)
ltest <- list(test2015, test2016, test2017, test2018)
names(ltest) <- c("test2015", "test2016", "test2017", "test2018")
# observation différence
plot(test2015$geometry)
plot(test2016$geometry, col = "red", add = TRUE)
plot(test2017$geometry, col = "blue", add = TRUE)
plot(test2018$geometry, col = "green", add = TRUE)
test_2015_2016 <- st_equals(test2015, test2016, sparse = T)
table(sapply(test_2015_2016, length))
# sur 21 geometries, 9 sont différentes...
rpg2015_2016  <- st_equals(st_make_valid(rpg2015), st_make_valid(rpg2016), sparse = T)
table(sapply(rpg2015_2016, length))
# meme proportion
```



### Zones d'étude

```{r}
alsace <- read.csv2("../dataE/00_ADMIN/alsace.csv")
names(alsace) <- c("zone", "PR", "nom", "CODE_CANTO")
canton2012 <- st_read("../dataE/00_ADMIN/canton2012/CANTON.SHP", quiet = TRUE, stringsAsFactors = TRUE)
str(alsace)
str(canton2012)
cantonS <- canton2012 [ canton2012$NOM_REG == "ALSACE",]
alsace.sf <- merge (cantonS, alsace, by = "CODE_CANTO")
alsace.sf <- alsace.sf [, c("CODE_CANTO", "ID_GEOFLA","zone", "PR", "nom" ),]
st_write(alsace.sf, "../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, delete_layer = TRUE)
plot(alsace.sf$geometry)
```

### Opérateurs spatiaux

![](../img/opspatiaux.png)
# Paramètres généraux

## Taille moyenne des parcelles agricole


```{r}
ldata <- list(rpg2015, rpg2016, rpg2017, rpg2018)
calcul <- function(data) {
  (sum(st_area(data)) / nrow(data))/10000
} 
sapply(ldata,calcul)
```

4,7 hac environ

## SAU moyenne

```{r}

```


# Méthodes possibles

## Centroides

Pour éviter les problèmes topologiques liés aux contours de parcelles. On utilise les centroides.

```{r}
data <- c("test2015", "test2016", "test2017", "test2018")
ldata <- list(test2015,test2016,test2017,test2018)
names(ldata) <- c("année1", "année2", "année3", "année4")
lcentr <- lapply(ldata, st_centroid)
str(lcentr)
aspect <- c(0,10,20,3)
col <- c("red", "green", "blue", "black")
plot(test2015$geometry)
for (i in 1:4) {
  plot(lcentr [[i]][10], pch = aspect [i], col = col [i], add = TRUE)
}
```

Assez peu de superposition des centroïdes. La solution est écartée.

## Grille

Comme les géométries ne semblent pas se superposer, on utilise une grille dont chaque carreau fait 1 hac.

https://rcarto.github.io/carto_avec_r/chapitre3.html#les-grilles-r%C3%A9guli%C3%A8res


![](../img/carroyage.png)

```{r}
grid <- st_make_grid(bb, cellsize = 100)
plot(test2015$geometry)
plot(grid, add = TRUE)
```


```{r}
inter <- function(data) { st_intersection(data, grid)}
linter <- lapply(ldata, inter)
sapply(linter, nrow)
```

La différence du nombre des carreaux montrent que les géométries sont différentes.

L'objet de référence est désormais une liste.

Cela permet d'appliquer rapidement les mêmes traitements avec *lapply* et des fonctions spécifiques  (cf fonction *inter* ci-dessus, permet d'intersecter les géométries avec la grille.

Inconvénient : manipulation des objets plus lourde ([[i]])

Avantage : éviter les boucles

Exemple de fonction : calculer le % aire pour chaque carré de la grille
Ceci permettra de donner une valeur continue à chaque carreau. Par exemple, si on veut cartographier
le % de maïs sur chacune des 4 années et comparer les cartes.

TO DO

```{r}
pct <- function(aire) { (aire / 10000) * 100}
laire <- lapply(linter, st_area)
lcoeff <- lapply(laire, pct)
```


Cependant dans le cas présent, la grille sert à rien. Puisqu'on utilise uniquement les opérateurs
spatiaux pour déterminer une aire qui servira de base au calcul.

L'équivalent serait de combiner les coeff pour obtenir une moyenne d'occupation de carreau par exemple.
Cela permettra de vérifier la justesse de nos résultats par manipulations spatiales.

TO DO


## Allègement des données, uniquement le maïs


L'idée est de retenir uniquement les carreaux maïs ("BTH" pour les besoins du test), cela allège considérablement la base !


```{r}
# filtrage des carreaux
sel <- function (data) {data [data [,4, drop = TRUE] == "BTH",]}
ldataBTH <- lapply (linter, sel)
couleur <- c("red","blue", "green", "black")
par(mar = c(0,0,1.2,0), mfrow = c(2,2))
i <- 1
for (i in 1:4) {
  plot(ldataBTH [[i]][10], border = couleur [i])
  layoutLayer(title = names(ldataBTH [i]))
}
```

ldataBTH est désormais notre objet de référence. 

# Manipulations spatiales

## Uniquement le maïs sur les 4 ans

Sur 4 ans, les carreaux maïs et rien d'autre.

```{r}
res1 <- st_intersection(ldataBTH$année1, ldataBTH$année2)
res2 <- st_intersection(res1, ldataBTH$année3)
res3 <- st_intersection (res2, ldataBTH$année4)
aireMais <- round(sum(st_area(res3))/10000,2)
plot(res3$geometry)
plot(test2015$geometry)
plot(res3, add = TRUE)
layoutLayer(paste0("aire blé cultivé uniquement en 2015 : ",aireMais, " ha"))
# on calcule l'aire de res3 uniquement
```

TO DO fonction récursive

TO DO pourquoi des points sur le plot ?

## Uniquement mais en 2015

Union des 3 années et différence avec 2015

sans quadrillage (problème de CRS avec le quadrillage)

```{r}
ltestBTH <- lapply (ldata, sel)
# assembler les polygones des différentes couches
Y <- st_union(st_union(ltestBTH$test2016), st_union(ltestBTH$test2017), st_union(ltestBTH$test2018))
X <- st_union(ltestBTH$test2015)
# graphique
par(mfrow = c(1,2))
plot(X)
plot(Y, col = "blue")
# parcelle où mais cultivé en 2015
res1 <- st_difference(X, Y)
plot(res1)
(round(st_area(res1),0))
```

Remarque : il faut appliquer une union des polygones avant de faire la différence sinon la différence
se fera sur chaque polygone
Du coup, on crée applique st_union une bonne fois pour toute !

```{r}
lunion <- lapply(ltestBTH, st_union)
```




## Uniquement mais en 2016, 2017, 2018

On crée une fonction ayant pour paramètre l'année de la demande.

```{r, eval=TRUE}
anneeUnique <- function(lunion, num) {
  X <- lunion [[num]]
  lreste <- lunion
  lreste [[num]] <- NULL
  Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]])
  res <- st_difference(X,Y )
  # graphique
  par(mfrow = c(1,3))
  plot(X, main = num)
  plot(Y, col = "blue", main = "autres")
  plot(res, main = "difference")
  round(st_area(res),0)
}
```


```{r}
lnum <- c(1,2,3,4)
sapply(lnum, anneeUnique)
```

TODO pb géometries pas complètes

## Deux ans sur les quatre ans

Intersection des années et différence entre les deux géométries créées
Directement en fonction

```{r, eval=TRUE}
deuxAnsOLD <- function (num1,num2, lunion) {
  X <- st_union(lunion [[num1]], lunion [[num2]])
  lreste <-lunion [c(-num1,-num2)]
  Y <- st_union (lreste [[1]], lreste [[2]])
  # Toutes les géométries de X qui ne sont pas dans Y
  res <- st_difference(X,Y )
  # couteux
  # graphique
  # par(mfrow = c(2, 2))
  # plot(X, main = paste(num1, num2))
  # plot(Y, col = "blue", main = "autres")
  # plot(res, main = "difference")
  # Elimination des petits petits polygones (500 m2)
  # TO DO valider cette limite
  
  #res2 <- st_cast(res, "MULTILINESTRING")
  res3 <- st_cast(res, "MULTIPOLYGON")
  res4 <- sapply(st_as_sf(res3), st_area)
  indice <- which(round(res4,0) > 500)
  #plot(res2 [indice], main = "retenu")
  res5 <- round(st_area (res3 [indice]),0)
  return(res5)
  }
num1 <- 1
num2 <- 2
lunion <- lzone2
lunion
deuxAns <- function (num1,num2, lunion) {
  X <- st_union(lunion [[num1]], lunion [[num2]])
  lreste <-lunion [c(-num1,-num2)]
  Y <- st_union (lreste [[1]], lreste [[2]])
  # Toutes les géométries de X qui ne sont pas dans Y
  res <- 
    st_cast(st_difference(X,Y ), "MULTIPOLYGON")
    
  # couteux
  # graphique
  # par(mfrow = c(2, 2))
  # plot(X, main = paste(num1, num2))
  # plot(Y, col = "blue", main = "autres")
  # plot(res, main = "difference")
  # Elimination des petits petits polygones (500 m2)
  # TO DO valider cette limite
  
  #res2 <- st_cast(res, "MULTILINESTRING")
  res2 <- sapply(st_as_sf(res), st_area)
  indice <- which(round(res2,0) > 500)
  #plot(res2 [indice], main = "retenu")
  res3 <- round(res2 [indice],0)
  return(res3)
  }

```


# Test sur zones Alsace

## Mise en forme des données : agrégation aux 4 zones de l'Alsace

Les données du RPG, même pour une seule région, sont très lourdes et le R de base les manipule mal, éclater
les fichiers selon des zones géographiques permettra de faciliter les traitements.

TODO exploration diplyr plus efficace que le R de base ?

TODO utiliser base postgis ?


```{r}
alsace <- st_read("../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, stringsAsFactors = FALSE)
rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE, stringsAsFactors = FALSE)
# agrégation par zones
aggAlsace <- aggregate(alsace [,c("zone"), drop = FALSE], by = list (alsace$zone), length)
names(aggAlsace)[1:2] <- c("groupe", "nb")
plot(aggAlsace$geometry, col = "antiquewhite1")
plot(lrpg[[1]], add = TRUE)
labelLayer(aggAlsace, txt = "groupe", halo = 2 )
#lrpg <- lapply(lrpg, st_union)
# intersection très couteuse.
intersecter <- function(data) {
  inter <- st_intersection(data, aggAlsace)
}
lrpg <- split(rpg, rpg$an)
lrpg <- lapply(lrpg, st_make_valid)
linter <- lapply(lrpg, intersecter)
inter <- do.call(rbind,linter)
data <- linter [[1]]
agg <- aggregate(data, by = list(data$groupe), length)
# sauvegarde pour éviter de refaire les manip trop coûteuse
st_write(agg, "../dataS/chrysomele.gpkg", "agg")
st_write(inter, "../dataS/chrysomele.gpkg", "inter")
```

## Utilisation des fonctions anneeUnique et deuxAns

Pour ces fonctions, il faut lister chaque zone sur toutes les années à partir de la donnée "inter".
Beaucoup de manipulations d'objet sous R...
Il faut également ne pas oublier d'appliquer les st_union sur chacun de ces objets. 

### Récupération de la donnée

```{r, eval=TRUE}
agg <- st_read("../dataS/chrysomele.gpkg", "agg", quiet = TRUE, stringsAsFactors = FALSE)
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# 276 000 obs
```


### Eclatement des données par zone, puis par année

TODO Est-ce nécessaire ?

```{r, eval=TRUE}
# on éclate les données par zone puis par an
lzone <- split(inter, inter$groupe)
eclaterZoneAn <- function (num) {
  df <- lzone[[num]]
  ldf <- split (df, df$an)
 # lunion <- lapply(ldf, st_union)
}
#lzone1 <- eclaterZoneAn (1)
lzone2 <- eclaterZoneAn (2)
lzone2
#lzone3 <- eclaterZoneAn (3)
lzone4 <- eclaterZoneAn (4)


# pb sur les géométries, le résultat est une collection de linestring

sfc <- st_union(lzone2 [[1]], "MULTIPOLYGON")

# tests utilisaton des foncitons par ordre de grandeur de lzone 
#avec lzone4 2.1 MB 
# puis lzone2 34.8
#zone3 50
# zone1 117
zone4AnneeUnique1 <-anneeUnique(lzone4, 1)
# en ha
zone4AnneeUnique1 /1000
zone4DeuxAns1 <- deuxAns(1,2, lzone4)
zone4DeuxAns1
# erreur stcast / il faut utiliser st_combine, argl
#zone2AnneeUnique1 <- anneeUnique (lzone2, 1)
```


