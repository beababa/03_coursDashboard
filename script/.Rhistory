comOK <- laire.pct.max [laire.pct.max >= 90]
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
comOK
names(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,2, drop = TRUE]
}
laire
linter
names(linter)
linter [[1]][,,2]
linter [[1]][,2]
linter [[1]][1,2]
linter [[1]][1,1]
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
#128 anomalies
nom.anomalies <- names(anomalies)
sel <- commune [commune$INSEE_COM %in% code4,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
nb <- length(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
comOK
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
names(comOK)
com2 <- communes [communes$INSEE_COM %in% comOK,]
com2 <- communes [commune$INSEE_COM %in% comOK,]
com2 <- commune [commune$INSEE_COM %in% comOK,]
comf <- rbind(com, com2)
indiceCom <-  which (res != 0)
Com <- commune[indiceCom,]
comf <- rbind(com, com2)
com <- commune[indiceCom,]
comf <- rbind(com, com2)
com2 <- commune [commune$INSEE_COM %in% comOK,]
str(commune)
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
INSEE_COMOK <- names(comOK)
com2 <- commune [commune$INSEE_COM %in% INSEE_COMOK,]
comf <- rbind(com, com2)
str(comf)
table(res)
res
comSegWiithin <- cbind (com, unlist(communeSegment) )
comSegWiithin
segment
tmp <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpCom <- cbind (com, unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
# 18190 communes dans segments
# filtre sur les communes problématiques, celles qui sont vides dans la liste
indiceComPb <- which(res == 0)
indiceComPb <- which(res == 0)
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
names(tmpSeg)
names(tmpCom)
tmpCom <- cbind (com, "Codgeo_NUm" = unlist(communeSegment) )
str(tmpCom)
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpCom)
str(tmpSeg)
library(sf)
library(cartography)
library(sf)
library(cartography)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
# 2 fichiers de segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
communeSegment <- st_within(commune, segment, sparse = T)
# recup des communes - segments
res <- sapply(communeSegment, length)
table(res)
indiceCom <-  which (res != 0)
com <- commune[indiceCom,]
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
indiceComPb <- which(res == 0)
comPb <- commune [indiceComPb,]
testCommuneSegment <- st_within(comPb, segment, sparse = T)
table(sapply(testCommuneSegment, length))
comSegment <- st_intersection(comPb, segment)
str(comSegment)
comSegment <- comSegment [, c("NOM_COM", "INSEE_COM", "codgeo", "libgeo")]
Aast <- comSegment [comSegment$NOM_COM == "Aast",]
Aast
plot(Aast$geom)
par(mfrow = c(1,3))
for (i in 1:3) { plot (Aast$geom [i])}
# une piste : taille des intersections ?
taille <- sapply(Aast$geom, st_area)
taille100 <- (taille / sum(taille)) *100
tab <- table(comSegment$"INSEE_COM")
table(tab)
max(tab)
# représentation graphique
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées entre 1 et 5 fois"))
code4 <- names(tab) [tab > 1]
par(mar = c(8,4,4,4))
tab4 <- tab [tab > 1]
# 46 communes conernées
barplot(sort(tab4), las = 2, main = paste0(length(tab4), " communes représentées plus de 4 fois"))
comSeg4 <- comSegment [comSegment$INSEE_COM %in% code4,]
# nb choix de la limite
nb <- 1
code4 <- names(tab) [tab > nb]
par(mar = c(8,4,4,4))
tab4 <- tab [tab > nb]
# 46 communes conernées
barplot(sort(tab4), las = 2, main = paste0(length(tab4), " communes représentées plus de ", nb,"  fois"))
comSeg4 <- comSegment [comSegment$INSEE_COM %in% code4,]
# nb choix de la limite
nb <- 1
code4 <- names(tab) [tab > nb]
par(mar = c(8,4,4,4))
tab4 <- tab [tab > nb]
barplot(sort(tab4), las = 2, main = paste0(length(tab4), " communes représentées plus de ", nb,"  fois"))
comSeg4 <- comSegment [comSegment$INSEE_COM %in% code4,]
sel <- commune [commune$INSEE_COM %in% code4,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
nb <- length(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
#128 anomalies
nom.anomalies <- names(anomalies)
plot(commune$geom [commune$NOM_COM == nom.anomalies,])
# 128 anomalies
nom.anomalies <- names(anomalies)
plot(commune$geometry [commune$NOM_COM == nom.anomalies,])
# 128 anomalies
nom.anomalies <- names(anomalies)
plot(commune$geom [commune$NOM_COM == nom.anomalies,])
plot(commune$geom [commune$INSEE_COM == nom.anomalies,])
str(commune)
plot(commune$geom)
str(commune$geom)
plot(commune$geom [commune$INSEE_COM %in% nom.anomalies,])
# sauf pour 5 communes sur les 46
nb <- length(nom.anomalies)
i <- 1
for (i in 1:nb) {
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
png(
paste0("../img/anomalies_", i, ".png"),
width = 300,
height = sizes [2],
res = 96
)
par(mar = c(0, 0, 1.2, 0))
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
# cartographie pour tous les cas
par(mfrow = c(7,7))
str(tmpCom)
table(res)
res
table(res)
communeSegment
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
table(res)
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
str(tmpSeg)
str(tmpCom)
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
str(tmpCom$Codgeo_NUM)
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
library(cartography)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
# 2 fichiers de segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
communeSegment <- st_within(commune, segment, sparse = T)
communeSegment
# recup des communes - segments
res <- sapply(communeSegment, length)
table(res)
# recup indice communes inclues 18190
indiceCom <-  which (res != 0)
# recup communes
com <- commune[indiceCom,]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgoe_NUM")], tmpSeg, by = "Codgeo_NUM")
# recup communes
com <- commune[indiceCom,]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgoe_NUM")], tmpSeg, by = "Codgeo_NUM")
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement !
diff(tmpCom, comSeg1)
# pb 16354 seulement !
diff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# pb 16354 seulement !
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
tmpSeg [tmpSeg$Codgeo_NUM == 156,]
communeSegment
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
tmpCom <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(tmpCom)
plot(segment$geometry)
plot(tmpCom, add = TRUE)
plot(segment$geometry)
plot(tmpCom, add = TRUE)
plot(tmpCom, col = "red", add = TRUE)
tmpCom156 <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(segment$geometry)
plot(tmpCom156, col = "red", add = TRUE)
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
tmpCom156 <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(segment$geometry)
plot(tmpCom156, col = "red", add = TRUE)
segment [segment$codgeo == 156,]
segment [segment$codgeo == "156",]
plot(segment$geometry, col = "blue")
plot(tmpCom156, col = "red", add = TRUE)
plot(tmpCom156, col = "red")
plot(tmpCom156$geom, col = "red")
plot(segment$geometry, add = TRUE, col = "blue")
labelLayer(segment$geometry)
labelLayer(segment, txt = "Codgeo_NUM")
plot(tmpCom156$geom, col = "red")
labelLayer(segment, txt = "Codgeo_NUM")
communeSegment
# il s'agit du segment 168. comment le 156 se transforme en 168. pb traitement within.
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
# cas du segement 29
tmpCom29 <-   tmpCom [tmpCom$Codgeo_NUM == 29,]
# cas du segement 29
tmpCom29 <-   tmpCom [tmpCom$Codgeo_NUM == 29,]
plot(tmpCom29$geom, col = "red")
plot(segment$geometry, add = TRUE, col = "blue")
segment [segment$codgeo == 29,]
segment [segment$codgeo == 29,]
plot(tmpCom29$geom, col = "red")
segment [segment$codgeo == 29,]
labelLayer(segment, txt = "Codgeo_NUM"
labelLayer(segment, txt = "Codgeo_NUM")
labelLayer(segment, txt = "Codgeo_NUM")
plot(segment$geometry, add = TRUE, col = "blue")
labelLayer(segment, txt = "Codgeo_NUM")
communeSegment
segment [29,]
communeSegment
unlist(communeSegment)
seg <- segment [unlist(communeSegment),]
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
seg <- segment [unique(unlist(communeSegment)),]
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# recup communes et segments via les indices
com <- commune[indiceCom,]
seg <- segment [unique(unlist(communeSegment)),]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# cartographie du segment 156
tmpCom156 <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(segment$geometry, add = TRUE, col = "blue")
plot(tmpCom156$geom, col = "red")
segment [segment$codgeo == 156,]
plot(segment$geometry, add = TRUE, col = "blue")
labelLayer(segment, txt = "Codgeo_NUM")
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, seg )
# recup communes et segments via les indices
com <- commune[indiceCom,]
seg <- segment [unlist(communeSegment),]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, seg )
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
unique(tmpSeg)
tmpsSeg <- unique(tmpSeg)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
tmpSeg <- unique(tmpSeg)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# 18190 communes dans segments
# filtre sur les communes problématiques, celles qui sont vides dans la liste
indiceComPb <- which(res == 0)
comPb <- commune [indiceComPb,]
comSegment <- st_intersection(comPb, segment)
str(comSegment)
comSegment <- comSegment [, c("NOM_COM", "INSEE_COM", "codgeo", "libgeo")]
tab <- table(comSegment$"INSEE_COM")
table(tab)
max(tab)
# représentation graphique
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées entre 1 et 5 fois"))
# nb choix de la limite
nb <- 1
code <- names(tab) [tab > nb]
par(mar = c(8,4,4,4))
# nb choix de la limite
nb <- 1
code <- names(tab) [tab > nb]
par(mar = c(8,4,4,4))
tab <- tab [tab > nb]
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées plus de ", nb,"  fois"))
comSeg <- comSegment [comSegment$INSEE_COM %in% code,]
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
sel <- commune [commune$INSEE_COM %in% code,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
nb <- length(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
# 128 anomalies
nom.anomalies <- names(anomalies)
plot(commune$geom [commune$INSEE_COM %in% nom.anomalies,])
comOK
# toutes les communes incluses (comSeg1)
# + toutes les communes segmentées (géométrie intersection <90 %) (comOK)
comSeg2 <- commune [commune$INSEE_COM %in% comOK]
linter
linter [[1]]
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- c(linter [[i]][,5, drop = TRUE], linter[[i]][,3, drop= TRUE])
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
laire
