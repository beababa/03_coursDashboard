par(0, 0, 1.2, 0)
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
par(0, 0, 1.2, 0)
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
# sauf pour 5 communes sur les 46
nb <- length(inter$geom [inter$NOM_COM == nom.anomalies])
i <- 1
for (i in 1:nb) {
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
png(
paste0("../img/anomalies_", i, ".png"),
width = 300,
height = sizes [2],
res = 96
)
par(mar = c(0, 0, 1.2, 0))
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
anomalies <- laire.pct.max [laire.pct.max <90]
nom.anomalies <- names(anomalies)
# sauf pour 5 communes sur les 46
nb <- length(inter$geom [inter$NOM_COM == nom.anomalies])
i <- 1
for (i in 1:nb) {
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
png(
paste0("../img/anomalies_", i, ".png"),
width = 300,
height = sizes [2],
res = 96
)
par(mar = c(0, 0, 1.2, 0))
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
anomalies <- laire.pct.max [laire.pct.max <90]
nom.anomalies <- names(anomalies)
# sauf pour 5 communes sur les 46
nb <- length(inter$geom [inter$NOM_COM == nom.anomalies])
nom.anomalies <- names(anomalies)
# sauf pour 5 communes sur les 46
nb <- length(inter$geom [inter$NOM_COM == nom.anomalies])
# sauf pour 5 communes sur les 46
nb <- length(nom.anomalies)
i <- 1
for (i in 1:nb) {
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
png(
paste0("../img/anomalies_", i, ".png"),
width = 300,
height = sizes [2],
res = 96
)
par(mar = c(0, 0, 1.2, 0))
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
# chargement donnée
data <- read.csv("../dataE/02_POI/bassin1.csv")
# chargement donnée
data <- read.csv2("../dataE/02_POI/bassin1.csv")
data
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
library(cartography)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
# 2 fichiers de segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
communeSegment <- st_within(commune, segment, sparse = T)
res <- sapply(communeSegment, length)
table(res)
str(communeSegment)
# filtre sur les communes problématiques, celles qui sont vides dans la liste
indiceComPb <- which(res == 0)
comPb <- commune [indiceComPb,]
testCommuneSegment <- st_within(comPb, segment, sparse = T)
table(sapply(testCommuneSegment, length))
### Vraiment est ce nécessaire.... juste pour m'assurer que j'ai bien compris
comSegment <- st_intersection(comPb, segment)
str(comSegment)
comSegment <- comSegment [, c("NOM_COM", "INSEE_COM", "codgeo", "libgeo")]
Aast <- comSegment [comSegment$NOM_COM == "Aast",]
Aast
plot(Aast$geom)
par(mfrow = c(1,3))
for (i in 1:3) { plot (Aast$geom [i])}
# une piste : taille des intersections ?
taille <- sapply(Aast$geometry, st_area)
taille100 <- (taille / sum(taille)) *100
taille100 <- (taille / sum(taille)) *100
tailleSum <-  lapply(taille, sum)
# une piste : taille des intersections ?
taille <- sapply(Aast$geometry, st_area)
# une piste : taille des intersections ?
taille <- sapply(Aast$geometry, st_area)
# une piste : taille des intersections ?
taille <- sapply(Aast$geom, st_area)
tailleSum <-  sapply(taille, sum)
sum(taille)
taille100 <- (taille / sum(taille))) *100
taille100 <- (taille / sum(taille)) *100
tab <- table(comSegment$"INSEE_COM")
table(tab)
max(tab)
# représentation graphique
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées entre 1 et 5 fois"))
code4 <- names(tab) [tab > 3]
par(mar = c(8,4,4,4))
tab4 <- tab [tab > 3]
# 46 communes conernées
barplot(sort(tab4), las = 2, main = paste0(length(tab4), " communes représentées plus de 4 fois"))
comSeg4 <- comSegment [comSegment$INSEE_COM %in% code4,]
sel <- commune [commune$INSEE_COM %in% code4,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:46) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,2, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
anomalies <- laire.pct.max [laire.pct.max <90]
nom.anomalies <- names(anomalies)
# sauf pour 5 communes sur les 46
nb <- length(nom.anomalies)
i <- 1
for (i in 1:nb) {
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
png(
paste0("../img/anomalies_", i, ".png"),
width = 300,
height = sizes [2],
res = 96
)
par(mar = c(0, 0, 1.2, 0))
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
# cartographie pour tous les cas
par(mfrow = c(7,7))
for (i in 1:46){
png(paste0("../img/inter_",i,".png"))
plot (linter [[i]][,6], border = "red", bg = "antiquewhite1")
plot(segment$geom, col = NA, add = TRUE)
layoutLayer(names(laire)[i])
dev.off()
}
# cartographie pour tous les cas
par(mfrow = c(7,7))
for (i in 1:46){
#png(paste0("../img/inter_",i,".png"))
plot (linter [[i]][,6], border = "red", bg = "antiquewhite1")
plot(segment$geom, col = NA, add = TRUE)
layoutLayer(names(laire)[i])
#dev.off()
}
dev.off()
# cartographie pour tous les cas
par(mfrow = c(7,7))
for (i in 1:46){
#png(paste0("../img/inter_",i,".png"))
plot (linter [[i]][,6], border = "red", bg = "antiquewhite1")
plot(segment$geom, col = NA, add = TRUE)
layoutLayer(names(laire)[i])
#dev.off()
}
#png(paste0("../img/inter_",i,".png"))
plot (linter [[i]][,6], border = "red", bg = "antiquewhite1")
plot(segment$geom, col = NA, add = TRUE)
layoutLayer(names(laire)[i])
code4 <- names(tab) [tab > 1]
par(mar = c(8,4,4,4))
tab4 <- tab [tab > 1]
# 46 communes conernées
barplot(sort(tab4), las = 2, main = paste0(length(tab4), " communes représentées plus de 4 fois"))
comSeg4 <- comSegment [comSegment$INSEE_COM %in% code4,]
sel <- commune [commune$INSEE_COM %in% code4,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:46) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,2, drop = TRUE]
}
dim(linter)
length(linter)
nb <- length(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,2, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
anomalies <- laire.pct.max [laire.pct.max <90]
nom.anomalies <- names(anomalies)
# sauf pour 5 communes sur les 46
nb <- length(nom.anomalies)
i <- 1
for (i in 1:nb) {
g <- inter$geom [inter$NOM_COM == nom.anomalies [i]]
sizes <-
getFigDim(
x = g,
width = 300,
mar = c(0, 0, 1.2, 0),
res = 96
)
png(
paste0("../img/anomalies_", i, ".png"),
width = 300,
height = sizes [2],
res = 96
)
par(mar = c(0, 0, 1.2, 0))
plot(g, bg = "antiquewhite1")
segSel <-
st_intersection(segment, g)
noms <- unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
#128 anomalies
nom.anomalies <- names(anomalies)
nom.anomalies
nom.anomalies
plot(commune$geom [commune$NOM_COM == nom.anomalies,])
names(linter)
table(res)
communeSegment [length(res)==1,]
str(communeSegment)
indiceCom <-  which [res != 0]
table(res)
table(res)
indiceCom <-  which (res != 0)
Com <- com [indiceCom,]
Com <- commune[indiceCom,]
comOK <- laire.pct.max [laire.pct.max >= 90]
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
comOK
names(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,2, drop = TRUE]
}
laire
linter
names(linter)
linter [[1]][,,2]
linter [[1]][,2]
linter [[1]][1,2]
linter [[1]][1,1]
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
#128 anomalies
nom.anomalies <- names(anomalies)
sel <- commune [commune$INSEE_COM %in% code4,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
nb <- length(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
comOK
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
names(comOK)
com2 <- communes [communes$INSEE_COM %in% comOK,]
com2 <- communes [commune$INSEE_COM %in% comOK,]
com2 <- commune [commune$INSEE_COM %in% comOK,]
comf <- rbind(com, com2)
indiceCom <-  which (res != 0)
Com <- commune[indiceCom,]
comf <- rbind(com, com2)
com <- commune[indiceCom,]
comf <- rbind(com, com2)
com2 <- commune [commune$INSEE_COM %in% comOK,]
str(commune)
# toutes les communes incluses (com)
# + toutes les communes segmentées (géométrie intersection <90 %)
# + anomalies
INSEE_COMOK <- names(comOK)
com2 <- commune [commune$INSEE_COM %in% INSEE_COMOK,]
comf <- rbind(com, com2)
str(comf)
table(res)
res
comSegWiithin <- cbind (com, unlist(communeSegment) )
comSegWiithin
segment
tmp <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpCom <- cbind (com, unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
# 18190 communes dans segments
# filtre sur les communes problématiques, celles qui sont vides dans la liste
indiceComPb <- which(res == 0)
indiceComPb <- which(res == 0)
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
names(tmpSeg)
names(tmpCom)
tmpCom <- cbind (com, "Codgeo_NUm" = unlist(communeSegment) )
str(tmpCom)
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpCom)
str(tmpSeg)
