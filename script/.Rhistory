typoLayer(segmentSel, var = "libgeo", add = TRUE)
plot(
inter$geom [inter$NOM_COM == nom.anomalies [i]],
lwd = 2,
border = "red",
add = TRUE,
col = NA
)
layoutLayer(paste0("Commune de", nom.anomalies [i],  " et segments"))
dev.off()
}
# cartographie pour tous les cas
par(mfrow = c(7,7))
str(tmpCom)
table(res)
res
table(res)
communeSegment
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
table(res)
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
str(tmpSeg)
str(tmpCom)
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg)
str(tmpCom)
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
str(tmpCom$Codgeo_NUM)
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
library(cartography)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
# 2 fichiers de segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
communeSegment <- st_within(commune, segment, sparse = T)
communeSegment
# recup des communes - segments
res <- sapply(communeSegment, length)
table(res)
# recup indice communes inclues 18190
indiceCom <-  which (res != 0)
# recup communes
com <- commune[indiceCom,]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM")], tmpSeg, by = "Codgeo_NUM")
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgoe_NUM")], tmpSeg, by = "Codgeo_NUM")
# recup communes
com <- commune[indiceCom,]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgoe_NUM")], tmpSeg, by = "Codgeo_NUM")
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement !
diff(tmpCom, comSeg1)
# pb 16354 seulement !
diff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# pb 16354 seulement !
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
tmpSeg [tmpSeg$Codgeo_NUM == 156,]
communeSegment
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
tmpCom <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(tmpCom)
plot(segment$geometry)
plot(tmpCom, add = TRUE)
plot(segment$geometry)
plot(tmpCom, add = TRUE)
plot(tmpCom, col = "red", add = TRUE)
tmpCom156 <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(segment$geometry)
plot(tmpCom156, col = "red", add = TRUE)
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  segment [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
tmpCom156 <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(segment$geometry)
plot(tmpCom156, col = "red", add = TRUE)
segment [segment$codgeo == 156,]
segment [segment$codgeo == "156",]
plot(segment$geometry, col = "blue")
plot(tmpCom156, col = "red", add = TRUE)
plot(tmpCom156, col = "red")
plot(tmpCom156$geom, col = "red")
plot(segment$geometry, add = TRUE, col = "blue")
labelLayer(segment$geometry)
labelLayer(segment, txt = "Codgeo_NUM")
plot(tmpCom156$geom, col = "red")
labelLayer(segment, txt = "Codgeo_NUM")
communeSegment
# il s'agit du segment 168. comment le 156 se transforme en 168. pb traitement within.
str(tmpSeg$Codgeo_NUM)
str(tmpCom$Codgeo_NUM)
# cas du segement 29
tmpCom29 <-   tmpCom [tmpCom$Codgeo_NUM == 29,]
# cas du segement 29
tmpCom29 <-   tmpCom [tmpCom$Codgeo_NUM == 29,]
plot(tmpCom29$geom, col = "red")
plot(segment$geometry, add = TRUE, col = "blue")
segment [segment$codgeo == 29,]
segment [segment$codgeo == 29,]
plot(tmpCom29$geom, col = "red")
segment [segment$codgeo == 29,]
labelLayer(segment, txt = "Codgeo_NUM"
labelLayer(segment, txt = "Codgeo_NUM")
labelLayer(segment, txt = "Codgeo_NUM")
plot(segment$geometry, add = TRUE, col = "blue")
labelLayer(segment, txt = "Codgeo_NUM")
communeSegment
segment [29,]
communeSegment
unlist(communeSegment)
seg <- segment [unlist(communeSegment),]
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
seg <- segment [unique(unlist(communeSegment)),]
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# recup communes et segments via les indices
com <- commune[indiceCom,]
seg <- segment [unique(unlist(communeSegment)),]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, "Codgeo_NUM" = unlist(communeSegment) )
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
tmpSeg$Codgeo_NUM <- as.integer(tmpSeg$Codgeo_NUM)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# cartographie du segment 156
tmpCom156 <-  tmpCom [tmpCom$Codgeo_NUM == 156,]
plot(segment$geometry, add = TRUE, col = "blue")
plot(tmpCom156$geom, col = "red")
segment [segment$codgeo == 156,]
plot(segment$geometry, add = TRUE, col = "blue")
labelLayer(segment, txt = "Codgeo_NUM")
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, seg )
# recup communes et segments via les indices
com <- commune[indiceCom,]
seg <- segment [unlist(communeSegment),]
# attribution du segment par jointure attributaire
tmpCom <- cbind (com, seg )
tmpSeg <-  seg [, c("Codgeo_NUM", "libgeo"), drop = TRUE]
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
unique(tmpSeg)
tmpsSeg <- unique(tmpSeg)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
tmpSeg <- unique(tmpSeg)
# une commune par segment donc 18190 obs
comSeg1 <- merge (tmpCom [, c("INSEE_COM", "NOM_COM","Codgeo_NUM")], tmpSeg, by = "Codgeo_NUM")
# pb 16354 seulement ! recherche des numéros de segments pas repris
setdiff(tmpCom$Codgeo_NUM, comSeg1$Codgeo_NUM)
# 18190 communes dans segments
# filtre sur les communes problématiques, celles qui sont vides dans la liste
indiceComPb <- which(res == 0)
comPb <- commune [indiceComPb,]
comSegment <- st_intersection(comPb, segment)
str(comSegment)
comSegment <- comSegment [, c("NOM_COM", "INSEE_COM", "codgeo", "libgeo")]
tab <- table(comSegment$"INSEE_COM")
table(tab)
max(tab)
# représentation graphique
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées entre 1 et 5 fois"))
# nb choix de la limite
nb <- 1
code <- names(tab) [tab > nb]
par(mar = c(8,4,4,4))
# nb choix de la limite
nb <- 1
code <- names(tab) [tab > nb]
par(mar = c(8,4,4,4))
tab <- tab [tab > nb]
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées plus de ", nb,"  fois"))
comSeg <- comSegment [comSegment$INSEE_COM %in% code,]
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
sel <- commune [commune$INSEE_COM %in% code,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
nb <- length(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
# on cherche l'aire max
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
comOK <- laire.pct.max [laire.pct.max >= 90]
anomalies <- laire.pct.max [laire.pct.max <90]
# 128 anomalies
nom.anomalies <- names(anomalies)
plot(commune$geom [commune$INSEE_COM %in% nom.anomalies,])
comOK
# toutes les communes incluses (comSeg1)
# + toutes les communes segmentées (géométrie intersection <90 %) (comOK)
comSeg2 <- commune [commune$INSEE_COM %in% comOK]
linter
linter [[1]]
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:nb) {
laire [[i]] <- c(linter [[i]][,5, drop = TRUE], linter[[i]][,3, drop= TRUE])
names (laire) [[i]] <- linter [[i]][1,1, drop = TRUE]
}
laire
library(sf)
library(cartography)
library(rgdal)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
library(sf)
library(cartography)
library(rgdal)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
data <- read.csv("../dataS/lien.csv", sep = "\t", dec = ".", header  = FALSE)
str(data)
names(data) <- c("ID_CANTON", "CULTURE", "SURFACE")
table(data$CULTURE)
canton2015$ID_CANTON <- as.integer(substring(canton2015$ID_GEOFLA, 21,29))
canton2015 <- st_read("../dataE/00_ADMIN/CANTON.SHP")
# on fait la jointure avec les géométries des cantons
data <- merge(data, canton2015, by = "ID_CANTON")
canton2015$ID_CANTON <- as.integer(substring(canton2015$ID_GEOFLA, 21,29))
str(canton2015)
# on fait la jointure avec les géométries des cantons
data <- merge(data, canton2015, by = "ID_CANTON")
str(data)
# pour fichier final
col <- c("NOM_REGION","SAU_HA", "CODE_CAN")
str(data)
# pour fichier final
col <- c("ID_CANTON", "NOM_CHF", "CODE_DEPT", "NOM_DEPT", "CODE_REG","NOM_REGION","SAU_HA", "CODE_CAN")
# calcul SAU comme somme de toutes les surfaces
names(data)
table(data$CULTURE)
names (table(data$CULTURE))
# calcul SAU comme somme de toutes les surfaces
names(data)
data$SAU_HA <-  aggregate(data$SURFACE, by = list (ID_CANTON), sum)
data$SAU_HA <-  aggregate(data$SURFACE, by = list (data$ID_CANTON), sum)
SAU <-  aggregate(data$SURFACE, by = list (data$ID_CANTON), sum)
SAU
names(SAU) <- c("ID_CANTON", "SAU_HA")
# transposer
t(data)
# calcul SAU comme somme de toutes les surfaces
names(data)
# transposer
dataTest <- head(data)
dataTest
t(dataTest)
# transposer
dataTest <- head(data [, c(col, "CULTURE")])
# calcul SAU comme somme de toutes les surfaces
names(data)
# transposer
dataTest <- head(data [, c("ID_CANTON", "CULTURE")])
dataTest
t(dataTest)
i <-  1
numCanton <- 1
dataT$ID_CANTON <- numCanton
dataT <- NA
dataT$ID_CANTON <- numCanton
dataT [,vculture[i]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vculture[i]]]
i <-  1
numCanton <- 1
dataT <- NA
dataT$ID_CANTON <- numCanton
dataT [,vCulture[i]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vCulture[i]]]
vCulture <- names (table(data$CULTURE))
dataT [,vCulture[i]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vCulture[i]]]
colnames(dataT) <- c("ID_CANTON",vCulture)
# créer un df
df <- data.frame(ID_CANTON = integer(), vculture = numeric())
# créer un df
df <- data.frame()
colnames(df) <- c("ID_CANTON",vCulture)
# créer un df
df <- data.frame(matrix(vector(),0,243,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
# créer un df
df <- data.frame(matrix(vector(),0,242,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
i <- 1
df$ID_CANTON <- numCanton
df$ID_CANTON [i]<- numCanton
i <- 1
df$ID_CANTON [i]<- numCanton
df [i, "ID_CANTON" ]<- numCanton
df
df [,vCulture[i]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vCulture[i]]]
df [,vCulture[j]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vCulture[j]]]
j <- 1
df [,vCulture[j]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vCulture[j]]]
vCulture [j]
df [,vCulture [j]]
df [,vCulture[j]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [, vCulture[j]],]
df [,vCulture[j]] <- data [data$ID_CANTON == numCanton& data$CULTURE == data [vCulture[j],],]
data [data$ID_CANTON == 1]
data [data$ID_CANTON == 1,]
data [data$ID_CANTON == 1&data$CULTURE == "BTH",]
data$SURFACE [data$ID_CANTON == 1&data$CULTURE == "BTH"]
surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]]
j <- 1
surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]]
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
vCulture [j]
j <- 2
vCulture [j]
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
data$CULTURE [data$ID_CANTON == 1]
vCulture
j <- 24
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
df [data$ID_CANTON [i],vCulture[j]] <- surface
df
# créer un df
df <- data.frame(matrix(vector(),0,242,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
i <- 1
for (numCanton in 1:length(unique(ID_CANTON))) {
df [i, "ID_CANTON" ]<- numCanton
df
j <- 24
for (j in 1:length(vCulture)) {
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
i <- 1
# créer un df
df <- data.frame(matrix(vector(),0,242,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
i <- 1
for (numCanton in 1:length(unique(data$ID_CANTON))) {
df [i, "ID_CANTON" ]<- numCanton
df
j <- 24
for (j in 1:length(vCulture)) {
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
df [data$ID_CANTON [i],vCulture[j]] <- surface
surface <- ifelse(length(surface == 0, 0, surface))
surface <- ifelse(length(surface) == 0, 0, surface))
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
# créer un df
df <- data.frame(matrix(vector(),0,242,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
i <- 1
for (numCanton in 1:length(unique(data$ID_CANTON))) {
df [i, "ID_CANTON" ]<- numCanton
df
j <- 24
for (j in 1:length(vCulture)) {
(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
# créer un df
df <- data.frame(matrix(vector(),0,242,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
i <- 1
for (numCanton in 1:length(unique(data$ID_CANTON))) {
df [i, "ID_CANTON" ]<- numCanton
df
j <- 1
for (j in 1:length(vCulture)) {
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
df
numCanton <- data$ID_CANTON [i]
df [i, "ID_CANTON" ]<- numCanton
f
f
# créer un df
df <- data.frame(matrix(vector(),0,242,
dimnames = list(c(), c("ID_CANTON",vCulture))),
stringsAsFactors = F)
i <- 1
for (numCanton in 1:length(unique(data$ID_CANTON))) {
numCanton <- data$ID_CANTON [i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
for (j in 1:length(vCulture)) {
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
length(unique(data$ID_CANTON))
i <- 1
numCanton <- data$ID_CANTON [i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
i <- 2
numCanton <- data$ID_CANTON [i]
numCanton
# 242 * 2378 = 575 M cellules à faire...
df
vnumCanton <- unique(data$ID_CANTON)
i <- 1
for (numCanton in 1:2) {
numCanton <- vnumCanton[i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
for (j in 1:length(vCulture)) {
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
df
i <- 1
for (numCanton in 1:3) {
numCanton <- vnumCanton[i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
for (j in 1:length(vCulture)) {
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
df
