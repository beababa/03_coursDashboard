choroLayer(
geomSansVide,
var =  cultures[i],
method = "jenks",
nclass = nb,
col = mypal,
border = NA,
legend.title.cex = 0.6,
legend.values.cex = 0.5,
legend.title.txt = "Nb d'ha",
legend.border = "gray96",
# pb sur les NA
legend.nodata = "inf. à 3 exploitations",
colNA = "white",
add = TRUE
)
# carte des valeurs vnulles
plot(geomVide$geom, col ="azure3", border = NA, lty = 1 , add = TRUE)
legend(x = "bottomleft", legend = "pas de culture", cex = 0.5, fill = "azure3",
border =NA, bty = "n" )
layoutLayer(title =substring(cultures [i], 6), tabtitle = TRUE,theme = lcouleurs [[i]], frame = FALSE,
postitle = "center", posscale = "topright")
plot(dptS$geometry, col=  NA, lty= 1, lwd = 1, border = "gray96", add = TRUE)
dev.off()
}
png("../img/barres.png", height = 600, width = 600, res = 100)
# fichier d'exemple, bio non bio valeurs aléatoires
data <-  st_read("../dataS/Carriere_A.gpkg", "data_Surf_avoine")
str(data)
data$bio <- sample(1:100,nrow(data))
data$nonbio <- sample(1:100, nrow(data))
mypal <- carto.pal(pal1 =  lcouleurs [[2]], n1 = nb)
plot(fr$geometry)
# carte des valeurs non vides
choroLayer(
data,
var =  cultures[2],
method = "geom",
nclass = nb,
col = mypal,
border = "gray96",
legend.title.cex = 0.6,
legend.values.cex = 0.5,
legend.title.txt = "Nb d'ha",
legend.border = "white",
legend.pos = "topleft",
# pb sur les NA
legend.nodata = "inf.à 3",
colNA = "white",
add = TRUE
)
plot(dptS$geometry, col= NA, lwd = 0.001, border = "gray96", add = TRUE)
data$tot <-  data$bio + data$nonbio
# une même taille pour légende et symboles carte
# on trace sur le total, le 2e item
taille <- 0.35
propSymbolsLayer(data, var = "tot", symbols = "bar", border = NA, add = T, legend.pos = "n", col = "olivedrab1", inches =  taille)
propSymbolsLayer(data, var = "nonbio", col = "olivedrab3", symbols = "bar",
border = NA,add = T,  legend.pos = "o", inches = taille)
legendBarsSymbols("left", var = c(min(data$tot), max(data$tot)), inches = taille, col = "white", title.txt = "nb ha bio \n/ nonbio")
legendTypo("topright", col = c("olivedrab3","olivedrab1"), categ = c("bio", "nonbio"), title.txt = "type culture",  nodata = F)
layoutLayer(title =substring(cultures [2], 6), tabtitle = TRUE,theme = lcouleurs [[2]], frame = FALSE,
postitle = "center", posscale = "bottomleft")
dev.off()
i <- 1
png(paste0("../img/carto",".png"),
width = 600 *4,
height = 600 * 4,
res = 200)
par(mfrow = c(4,4))
for (i in 1:16) {
# traitement des valeurs nulles (= blanc) : on fait une carte pour les nuls et une carte sans
geomVide <- jointure [jointure [[i+1]] == 0  , i+1, drop = FALSE]
geomVide <- geomVide [!is.na(geomVide [[1]]),]
geomSansVide <- jointure [jointure [[i+1]] != 0 , i+1, drop = FALSE]
geomSansVide <- geomSansVide [!is.na(geomSansVide [[1]]),]
geomNA <- jointure [is.na (jointure [[i+1]]),i+1]
geomSansVide <- rbind (geomSansVide, geomNA)
# enregistrement des couches pour QGIS
st_write(geomVide, "../dataS/Carriere_A.gpkg", paste0("geomVide_", cultures [i]), quiet = TRUE, delete_layer = TRUE)
st_write(geomSansVide, "../dataS/Carriere_A.gpkg", paste0("data_", cultures[i]), quiet = TRUE, delete_layer = TRUE)
head(geomSansVide)
head(geomNA)
head(geomVide)
# variables pour lin, le nobmre de classes est 3 seulement
nb <- ifelse(i == 8,  3,5)
mypal <- carto.pal(pal1 =  lcouleurs [[i]], n1 = nb)
par(mar=c(0,0,1.2,0))
#centrage sur l'ensemble de la France
plot(fr$geometry, col= NA, border = NA)
# carte des valeurs non vides
choroLayer(
geomSansVide,
var =  cultures[i],
method = "jenks",
nclass = nb,
col = mypal,
border = NA,
legend.title.cex = 0.6,
legend.values.cex = 0.5,
legend.title.txt = "Nb d'ha",
legend.border = "gray96",
# pb sur les NA
legend.nodata = "inf. à 3",
colNA = "white",
add = TRUE
)
# carte des valeurs vnulles
plot(geomVide$geom, col ="azure3", border = NA, lty = 1 , add = TRUE)
legend(x = "bottomleft", legend = "pas de culture", cex = 0.5, fill = "azure3",
border =NA, bty = "n" )
layoutLayer(title =substring(cultures [i], 6), tabtitle = TRUE,theme = lcouleurs [[i]], frame = FALSE,
postitle = "center")
plot(dpt$geometry, col= NA, lty= 1, lwd = 1, border = "gray96", add = TRUE)
}
dev.off()
i <- 1
for (i in 1:16) {
png(paste0("../img/carto",cultures [i],".png"),
width = 600,
height = 600,
res = 150)
par(lwd = 0.1)
# traitement des valeurs nulles (= blanc) : on fait une carte pour les nuls et une carte sans
geomVide <- jointure [jointure [[i+1]] == 0  , i+1, drop = FALSE]
geomVide <- geomVide [!is.na(geomVide [[1]]),]
geomSansVide <- jointure [jointure [[i+1]] != 0 , i+1, drop = FALSE]
geomSansVide <- geomSansVide [!is.na(geomSansVide [[1]]),]
geomNA <- jointure [is.na (jointure [[i+1]]),i+1]
geomSansVide <- rbind (geomSansVide, geomNA)
# variables pour lin, le nobmre de classes est 3 seulement
nb <- ifelse(i == 8,  3,5)
mypal <- carto.pal(pal1 =  lcouleurs [[i]], n1 = nb)
par(mar=c(0,0,1.2,0))
#centrage sur l'ensemble de la France
plot(fr$geometry, col= NA, lwd = 1,border = NA)
# carte des valeurs non vides
choroLayer(
geomSansVide,
var =  cultures[i],
method = "jenks",
nclass = nb,
col = mypal,
border = NA,
legend.title.cex = 0.6,
legend.values.cex = 0.5,
legend.title.txt = "Nb d'ha",
legend.border = "gray96",
# pb sur les NA
legend.nodata = "inf. à 3 exploitations",
colNA = "white",
add = TRUE
)
# carte des valeurs vnulles
plot(geomVide$geom, col ="azure3", border = NA, lty = 1 , add = TRUE)
legend(x = "bottomleft", legend = "pas de culture", cex = 0.5, fill = "azure3",
border =NA, bty = "n" )
layoutLayer(title =substring(cultures [i], 6), tabtitle = TRUE,theme = lcouleurs [[i]], frame = FALSE,
postitle = "center", posscale = "topright")
plot(dpt$geometry, col=  NA, lty= 1, lwd = 1, border = "gray96", add = TRUE)
dev.off()
}
png("../img/barres.png", height = 600, width = 600, res = 100)
# fichier d'exemple, bio non bio valeurs aléatoires
data <-  st_read("../dataS/Carriere_A.gpkg", "data_Surf_avoine")
str(data)
data$bio <- sample(1:100,nrow(data))
data$nonbio <- sample(1:100, nrow(data))
mypal <- carto.pal(pal1 =  lcouleurs [[2]], n1 = nb)
plot(fr$geometry)
# carte des valeurs non vides
choroLayer(
data,
var =  cultures[2],
method = "geom",
nclass = nb,
col = mypal,
border = "gray96",
legend.title.cex = 0.6,
legend.values.cex = 0.5,
legend.title.txt = "Nb d'ha",
legend.border = "white",
legend.pos = "topleft",
# pb sur les NA
legend.nodata = "inf.à 3",
colNA = "white",
add = TRUE
)
plot(dpt$geometry, col= NA, lwd = 0.001, border = "gray96", add = TRUE)
data$tot <-  data$bio + data$nonbio
# une même taille pour légende et symboles carte
# on trace sur le total, le 2e item
taille <- 0.35
propSymbolsLayer(data, var = "tot", symbols = "bar", border = NA, add = T, legend.pos = "n", col = "olivedrab1", inches =  taille)
propSymbolsLayer(data, var = "nonbio", col = "olivedrab3", symbols = "bar",
border = NA,add = T,  legend.pos = "o", inches = taille)
legendBarsSymbols("left", var = c(min(data$tot), max(data$tot)), inches = taille, col = "white", title.txt = "nb ha bio \n/ nonbio")
legendTypo("topright", col = c("olivedrab3","olivedrab1"), categ = c("bio", "nonbio"), title.txt = "type culture",  nodata = F)
layoutLayer(title =substring(cultures [2], 6), tabtitle = TRUE,theme = lcouleurs [[2]], frame = FALSE,
postitle = "center", posscale = "bottomleft")
dev.off()
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
library(sf)
library(cartography)
library(xlsx)
getwd()
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
fr <-  st_read("../dataE/00_ADMIN/France_l93_continent4_buf2.shp")
data <- read.xlsx("../dataE/01_PONCTUELSGPS/LieuxpiegesDiabroticaAquitaine2020.xlsx",1, stringsAsFactors = F )
data <- read.xlsx("../dataE/02_POI/LieuxpiegesDiabroticaAquitaine2020.xlsx",1, stringsAsFactors = F )
library(sf)
library(cartography)
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
fr <-  st_read("../dataE/00_ADMIN/France_l93_continent4_buf2.shp")
st_simplify(dpt, 10000)
st_simplify(dpt, 1000)
st_simplify(dpt, preserveTopology = FALSE, dTolerance = 10)
plot(res)
res <- st_simplify(dpt, preserveTopology = FALSE, dTolerance = 10)
plot(res)
plot(res$geometry)
simplifier <- function (x, tol) {st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)}
simplifier <- function (x, tol) {
st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)
plot(res$geometry)}
simplifier <- function (x, tol) {
st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)
plot(res$geometry)}
simplifier(dpt, 100)
simplifier(dpt, 100)
v <- rep(10,10000, 1000)
v <- seq(10,10000, 1000)
v <- seq(0,10000, 1000)
simplifier <- function (tol) {
st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)
plot(res$geometry)}
simplifier( 100)
v <- seq(0,10000, 1000)
lapply(v, simplifier)
simplifier <- function (tol) {
st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)
png(paste0("img/tol",tol,".png"))
plot(res$geometry)
dev.off}
simplifier( 100)
st_simplify(dpt, preserveTopology = FALSE, dTolerance = 10)
res <- st_simplify(dpt, preserveTopology = FALSE, dTolerance = 10)
plot(res$geometry)
res <- st_simplify(dpt, preserveTopology = FALSE, dTolerance = 10)
plot(res$geometry, main = 10)
simplifier <- function (tol) {
st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)
png(paste0("img/tol",tol,".png"))
plot(res$geometry, main = tol)
dev.off}
simplifier( 100)
png("img/tol10.png")
res <- st_simplify(dpt, preserveTopology = FALSE, dTolerance = 10)
plot(res$geometry, main = 10)
dev.off()
simplifier <- function (tol) {
st_simplify(dpt, preserveTopology = FALSE, dTolerance = tol)
png(paste0("img/tol",tol,".png"))
plot(res$geometry, main = tol)
dev.off}
simplifier( 100)
v <- seq(0,10000, 1000)
png("img/")
lapply(v, simplifier)
library(sf)
library(cartography)
commune <- st_read("../dataE/00_ADMIN/commune.shp", stringsAsFactors = F)
segment <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
str(segment)
str(commune)
SegmentCommune <-  st_intersection(segment, commune)
CommuneSegment <-  st_intersection(segment, commune)
CommuneSegment <-  st_intersection(commune, segment)
plot(CommuneSegment$geometry)
malesherbes <- commune  [commune$NOM_COM == "Malesherbes",]
str(commune$NOM_COM)
liste <-  commune$NOM_COM
malesherbes <- commune  [commune$NOM_COM == "Le Malesherbois",]
plot(malesherbes$geometry)
plot(CommuneSegment$geometry, add = TRUE)
str(CommuneSegment)
head(CommuneSegment [, c("NOM_COM", "c_segment")])
table(CommuneSegment$c_segment)
table(CommuneSegment$c_segment, CommuneSegment$NOM_COM)
tab <- table(CommuneSegment$c_segment, CommuneSegment$NOM_COM)
head(tab)
tab <- table(CommuneSegment$NOM_COM)
head(tab)
plot(CommuneSegment [CommuneSegment$NOM_COM == "Aast",])
plot(CommuneSegment$geometry [CommuneSegment$NOM_COM == "Aast",])
Aast <- CommuneSegment$geometry [CommuneSegment$NOM_COM == "Aast",]
plot(Aast$geometry)
Aast <- CommuneSegment$geometry [CommuneSegment$NOM_COM == "Aast",]
plot(Aast$geometry)
Aast
Aast <- CommuneSegment [CommuneSegment$NOM_COM == "Aast",]
Aast
plot(Aast$geometry)
par(mfrow = c(1,3))
for (i in 1:3) { plot (Aast [i])}
par(mfrow = c(1,3))
for (i in 1:3) { plot (Aast$geometry [i])}
histo(tab)
barplot(tab)
barplot(tab)
summary(tab)
min(tab)
max(tab)
means(tab)
mean(tab)
names(tab) [tab > 2]
names(tab) [tab > 4]
names(tab) [tab > 7]
noms8 <- names(tab) [tab > 7]
tab > 7
tab [tab > 7]
tab8 <- tab [tab > 7]
barplot(tab8)
barplot(tab8, )
barplot(sort(tab8))
barplot(sort(tab8), las = 1)
barplot(sort(tab8), las = 2)
mar(4,1,1,1)
tab8 <- tab [tab > 7]
mar = c(4,1,1,1)
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2)
mar = c(1,4,1,1)
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2)
mar = c(1,8,1,1)
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2)
par(mar = c(1,8,1,1))
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2)
par(mar = c(8,1,1,1))
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2)
barplot(sort(tab8), las = 2, main = "communes représentées plus de 8 fois")
par(mar = c(8,2,2,2))
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2, main = "communes représentées plus de 8 fois")
par(mar = c(8,4,4,4))
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2, main = "communes représentées plus de 8 fois")
communeSegment8 <- communeSegment [CommmuneSegment$NOM_COM %in% noms8,]
communeSegment8 <- CommuneSegment [CommmuneSegment$NOM_COM %in% noms8,]
View(segment)
commune <- st_read("../dataE/00_ADMIN/commune.shp", stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
library(sf)
library(cartography)
commune <- st_read("../dataE/00_ADMIN/commune.shp", stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(cartography)
commune <- st_read("../dataE/00_ADMIN/commune.shp", stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
# plusieurs couches segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
str(segment)
str(segmentV11)
# pas les mêmes variables V11 moins protocolaire
egal <- st_equals(segment, segmentV11, sparse = TRUE)
# on teste la présence d'une géométrie non identique
table (sapply(egal, length))
# les 192 géométries sont identiques !
communeSegment <- st_within(commune, segment, sparse = T)
table(sapply(communeSegment, length))
communeSegmentV11 <- st_intersection(commune, segmentV11)
communeSegmentV11 <- communeSegmentV11 [, c("NOM_COM", "c_segment")]
Aast <- communeSegmentV11 [communeSegmentV11$NOM_COM == "Aast",]
Aast
par(mfrow = c(1,3))
for (i in 1:3) { plot (Aast$geometry [i])}
# une piste : taille des intersections ?
taille <- sapply(Aast$geometry, st_area)
taille100 <- (taille / sum(taille)) *100
taille <- sapply(Aast$geometry, st_area)
taille <- sapply(Aast$geometry, st_area)
tab <- table(communeSegmentV11$NOM_COM)
max(tab)
noms8 <- names(tab) [tab > 7]
par(mar = c(8,4,4,4))
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2, main = "communes représentées plus de 8 fois")
barplot(sort(tab8), las = 2, main = "communes représentées plus de 8 fois")
sapply(communeSeg8, st_area)
sapply(communeSeg8, st_area)
sapply(comSeg8, st_area)
comSeg8 <- communeSegmentV11 [communeSegmentV11$NOM_COM %in% noms8,]
sapply(comSeg8, st_area)
sapply(comSeg8$geometry, st_area)
comSeg8$aire <- sapply(comSeg8$geometry, st_area)
str(commune)
commune [commune$NOM_COM in %noms8%, c("NOM_COM")]
commune [commune$NOM_COM %in% noms8, c("NOM_COM")]
com8 <- commune [commune$NOM_COM %in% noms8, c("NOM_COM")]
commune8$aire <- sapply(commune$geometry, st_area)
com8 <- commune [commune$NOM_COM %in% noms8, c("NOM_COM")]
com8$aire <- sapply(com8$geometry, st_area)
tab
tab8
df_tab8 <- as.data.frame(tab8)
merge (com8, df_tab8, by.x = "NOM_COM", by.y = "Var.1")
View(df_tab8)
merge (com8, df_tab8, by.x = "NOM_COM", by.y = "Var1")
df_tab8
com8 <- commune [commune$NOM_COM %in% noms8, c("NOM_COM")]
com8
sort(com8)
com8 [order(com8$NOM_COM),]
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
library(cartography)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
# 2 fichiers de segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
communeSegment <- st_within(commune, segment, sparse = T)
res <- sapply(communeSegment, length)
table(res)
str(communeSegment)
# filtre sur les communes problématiques, celles qui sont vides dans la liste
indiceComPb <- which(res == 0)
comPb <- commune [indiceComPb,]
testCommuneSegment <- st_within(comPb, segment, sparse = T)
table(sapply(testCommuneSegment, length))
comSegment <- st_intersection(comPb, segment)
comSegment <- comSegment [, c("NOM_COM", "INSEE_COM", "codgeo", "libgeo")]
Aast <- comSegmentV11 [comSegmentV11$NOM_COM == "Aast",]
Aast
Aast <- comSegmentV11 [comSegmentV11$NOM_COM == "Aast",]
tab <- table(comSegment$"INSEE_COM")
max(tab)
# représentation graphique
barplot(sort(tab), las = 2, main = paste0(length(tab), " communes représentées entre 1 et 5 fois"))
code4 <- names(tab) [tab > 3]
par(mar = c(8,4,4,4))
tab4 <- tab [tab > 3]
# 46 communes conernées
barplot(sort(tab4), las = 2, main = paste0(length(tab4), " communes représentées plus de 4 fois"))
comSeg4 <- comSegment [comSegment$INSEE_COM %in% code4,]
sel <- commune [commune$INSEE_COM %in% code4,]
inter <- st_intersection(sel, segment)
# aire des communes et de leurs parties
sel$aire <- sapply(sel$geom, st_area)
inter$aire <- sapply(inter$geom, st_area)
inter <- inter [, c("INSEE_COM", "NOM_COM", "codgeo", "libgeo","aire")]
str(inter)
# il s'agit d'obtenir les rapports entre les aires par ville
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
# Pour pouvoir traiter chaque ville, on éclate en liste
linter <- split(inter, inter$INSEE_COM)
names(linter)
# l'aire est sur chaque 5e col de chacune des 46 listes
# On extrait pour toutes les listes uniquement la 5e colonne
laire <- list()
for (i in 1:46) {
laire [[i]] <- linter [[i]][,5, drop = TRUE]
names (laire) [[i]] <- linter [[i]][1,2, drop = TRUE]
}
# on cherche l'aire max déjà
laire.pct <- lapply (laire, pct)
# on voit qu'il existe tjrs une aire principale occupant + de 90 % de la surface.
laire.pct.max <- lapply(laire.pct, max)
print(laire.pct.max)
# sauf pour Peyruis
comm <- "Peyruis"
length(inter$geom [inter$NOM_COM == comm])
plot(inter$geom [inter$NOM_COM == comm], bg = "antiquewhite1")
segSel <- st_intersection(segment, inter$geom [inter$NOM_COM == comm])
noms <-unique(segSel$libgeo)
segmentSel <- segment [segment$libgeo %in% noms,]
typoLayer(segmentSel, var = "libgeo",add = TRUE)
plot(inter$geom [inter$NOM_COM == "Peyruis"], lwd = 2, border = "red",add = TRUE, col = NA)
layoutLayer("Commune de Peyruis et segments, 2 intersections majeures")
# cartographie pour tous les cas
sel
