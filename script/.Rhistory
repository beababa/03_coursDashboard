}
lzone4 <- eclater (4)
lzone2 <- eclater (2)
lzone2
lzone3 <- eclater (3)
lzone1 <- eclater (1)
warnings()
# 149 / 43.2 / 64.1 et 3 M°
# enregistrement en fichiers pour qgis
df <- lzone4$`2015`
#  on récupère le nom de la zone
zone <- substring(deparse(substitute(df)),1,6)
print(zone)
annee <- names(df)
# 149 / 43.2 / 64.1 et 3 M°
# enregistrement en fichiers pour qgis
lzone4$`2015` <- lzone4$`2015`
#  on récupère le nom de la zone
zone <- substring(deparse(substitute(df)),1,6)
#  on récupère le nom de la zone
zone <- substring(deparse(substitute(lzone4$`2015`)),1,6)
annee <- substring(deparse(substitute(lzone4$`2015`)),8,12)
annee <- substring(deparse(substitute(lzone4$`2015`)),9,12)
# 149 / 43.2 / 64.1 et 3 M°
# enregistrement en fichiers pour qgis`
enregistrer <- function(df,num) {
#  on récupère le nom de la zone
zone <- substring(deparse(substitute(lzone4$`2015`)),1,6)
annee <- substring(deparse(substitute(lzone4$`2015`)),9,12)
st_write(df, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_", annee), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4) {
enregistrer(lzone1[[i]])
}
for (i in 1:4) {
enregistrer(lzone2[[i]])
}
for (i in 1:4) {
enregistrer(lzone3[[i]])
}
for (i in 1:4) {
enregistrer(lzone4[[i]])
}
lzone
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
union <- st_union(poly)
poly2 <- st_cast(sfc, "POLYGON")
}
lzone4$`2017`
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lpoly <- lapply(ldf, nettoyerGeom)
}
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
union <- st_union(poly)
poly2 <- st_cast(sfc, "POLYGON")
}
lzone4 <- eclater (4)
lzone4$`2017`
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
union <- st_union(poly)
poly2 <- st_cast(sfc, "POLYGON")
}
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
union <- st_union(poly)
poly2 <- st_cast(sfc, "POLYGON")
}
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lpoly <- lapply(ldf, nettoyerGeom)
}
lzone4 <- eclater (4)
lzone4`
lzone4
)
''
))))))
;
"""
lzone4
lzone4 <- eclater (4)
lzone4
fdsfdssd
lzone4 <- eclater (4)
lzone4
# 149 / 43.2 / 64.1 et 3 M°
# enregistrement en fichiers pour qgis`
enregistrer <- function(df,num) {
#  on récupère le nom de la zone
zone <- substring(deparse(substitute(lzone4$`2015`)),1,6)
annee <- substring(deparse(substitute(lzone4$`2015`)),9,12)
st_write(df, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_", annee), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4) {
enregistrer(lzone1[[i]])
}
lzone4
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lnettoye <- lapply(ldf, nettoyerGeom)
lunion <- lapply(lnettoye, st_union)
lpoly <- st_cast(lunion, "POLYGON")
}
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
}
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lnettoye <- lapply(ldf, nettoyerGeom)
lunion <- lapply(lnettoye, st_union)
lpoly <- st_cast(lunion, "POLYGON")
}
lzone4 <- eclater (4)
poly <- function(df) {
poly <- st_cast(df, "POLYGON")
}
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
}
polygoner <- function(df) {
poly <- st_cast(df, "POLYGON")
}
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lnettoye <- lapply(ldf, nettoyerGeom)
lunion <- lapply(lnettoye, st_union)
lpoly <- lapply(lunion, polygoner )
}
lzone4 <- eclater (4)
lzone4
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(sfc, "POLYGON")
}
polygoner <- function(df) {
poly <- st_cast(df, "POLYGON")
}
#df <-  lzone[[4]]
nettoyerGeom <- function (sfc) {
sfc <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
valid <- st_make_valid(sfc)
poly <- st_cast(valid, "POLYGON")
}
polygoner <- function(df) {
poly <- st_cast(df, "POLYGON")
}
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lnettoye <- lapply(ldf, nettoyerGeom)
lunion <- lapply(lnettoye, st_union)
lpoly <- lapply(lunion, polygoner )
}
lzone4
lzone4 <- eclater (4)
lzone4
lzone4Union <- lapply(lzone4, st_union)
lzone4
st_union(lzone4$`2015`)
lzone4Union <- lapply(lzone4, st_union)
lzone4 <- eclater (4)
lzone4Union <- lapply(lzone4, st_union)
lzone4
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
lnettoye <- lapply(ldf, nettoyerGeom)
lunion <- lapply(lnettoye, st_union)
lpoly <- lapply(lunion, polygoner )
}
lzone4 <- eclater (4)
lzone4
st_union(lzone4$`2015`)
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# on unit toutes les géométries
#lunion <- lapply(ldf, st_union)
#lnettoye <- lapply(ldf, nettoyerGeom)
# lunion <- lapply(lnettoye, st_union)
#lpoly <- lapply(lunion, polygoner )
}
lzone4 <- eclater (4)
lzone4
#df <-  lzone[[4]]
nettoyerGeom <- function (df) {
df <-sfc [st_geometry_type(sfc) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(valid, "POLYGON")
}
lzone4OK <- lapply(lzone4, nettoyerGeom)
#df <-  lzone[[4]]
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(valid, "POLYGON")
}
lzone4OK <- lapply(lzone4, nettoyerGeom)
#df <-  lzone[[4]]
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(dfvalid, "POLYGON")
}
lzone4OK <- lapply(lzone4, nettoyerGeom)
lzone4
polygoner <- function(df) {
dfunion <- st_union(df)
dfpoly <- st_cast(dfunion, "POLYGON")
}
lzone4Po <- lapply(lzone4OK, polygoner)
lzone4Po
summary(lzone4Po)
summary(lzone4)
summary(lzone4OK)
summary(lzone[[4]])
# boucle sur les zones
i <- 4
llzone <- lzone [[î]]
# boucle sur les années
j <- 4
leclate <- lapply(llzone, j)
# boucle sur les zones
i <- 4
llzone <- lzone [[î]]
# boucle sur les années
j <- 4
leclate <- eclater (llzone, j)
# boucle sur les zones
i <- 4
llzone <- lzone [[î]]
llzone <- lzone [[i]]
# boucle sur les années
j <- 4
leclate <- eclater (llzone, j)
# boucle sur les années
j <- 4
# boucle sur les zones
i <- 4
dfzone <- lzone [[i]]
# boucle sur les années
j <- 4
# boucle sur les années
j <- 1
leclate <- eclater (dfzone, j)
leclate <- eclater (j)
# boucle sur les zones
i <- 4
leclate <- eclater (j)
# boucle sur les zones
i <- 4
leclate <- eclater (i)
lpropre <- lapply(leclate, nettoyerGeom)
lpropre
lpolygoner <- lapply(lpropre,polygoner)
lpolygoner
lpolygoner <- lapply(lpropre,polygoner)
lpropre
# boucle sur les zones
i <- 4
leclate <- eclater (i)
# lapply  sur les années
lpropre <- lapply(leclate, nettoyerGeom)
paste0("lzone", i,) <- lapply(lpropre,polygoner)
paste0("lzone", i) <- lapply(lpropre,polygoner)
# boucle sur les zones
i <- 4
leclate <- eclater (i)
# lapply  sur les années
lpropre <- lapply(leclate, nettoyerGeom)
lpoly <- lapply(lpropre,polygoner)
lpoly
paste0 ("zone", i) <- lpoly
# boucle sur les zones
i <- 4
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
leclate <- eclater (i)
# lapply  sur les années
lpropre <- lapply(leclate, nettoyerGeom)
lpoly <- lapply(lpropre,polygoner)
noms [i] <- lpoly
assign(noms [i]) <- lpoly
assign(noms [i], lpoly)
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
# boucle sur les zones
i <- 4
assign(noms [i], lpoly)
# boucle sur les zones
i <- 1
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
for (i in 1:4){
leclate <- eclater (i)
# lapply  sur les années
lpropre <- lapply(leclate, nettoyerGeom)
lpoly <- lapply(lpropre,polygoner)
assign(noms [i], lpoly)
}
anneeUnique <- function(lunion, num) {
X <- lunion [[num]]
lreste <- lunion
lreste [[num]] <- NULL
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]])
res <- st_difference(X,Y )
# graphique
# par(mfrow = c(1, 3))
# plot(X, main = num)
# plot(Y, col = "blue", main = "autres")
# plot(res, main = "difference")
round(st_area(res),0)
}
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
lzone4
lunion <- lapply(lzone4, st_union)
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
lzone4
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
lzone4
lunion <- lapply(lzone4, st_union)
lunion
res <- NULL
for (i in 1:4){
res <- c(res, anneeUnique(lunion,i))
}
res/10000
lunion <- lapply(lzone4, st_union)
res <- NULL
for (i in 1:4){
res <- c(res, anneeUnique(lunion,i))
}
anneeUnique <- function(lunion, num) {
X <- lunion [[num]]
lreste <- lunion
lreste [[num]] <- NULL
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]])
res <- st_difference(X,Y)
# graphique
# par(mfrow = c(1, 3))
# plot(X, main = num)
# plot(Y, col = "blue", main = "autres")
# plot(res, main = "difference")
round(st_area(res)/10000,0)
}
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
lzone4
lunion <- lapply(lzone4, st_union)
res <- NULL
for (i in 1:4){
res <- c(res, anneeUnique(lunion,i))
}
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
# parcours de la zone
noms <- c("lzone1", "lzone2", "lzone3", "lzone4")
j <- 1
lzone <- noms [1]
j <- 4
lzone <- noms [j]
lunion <- lapply(lzone, st_union)
j <- 4
lzoneSel <- objet [j]
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
# parcours de la zone
objet <- c(lzone1, lzone2, lzone3, lzone4)
j <- 4
lzoneSel <- objet [j]
lunion <- lapply(lzonesel, st_union)
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
# parcours de la zone
objet <- c(lzone1, lzone2, lzone3, lzone4)
j <- 4
lzoneSel <- objet [j]
lunion <- lapply(lzoneSel, st_union)
res <- NULL
for (i in 1:4){
res <- c(res, anneeUnique(lunion,i))
}
lzoneSel
lzoneSel
lzone4
lunion
lunion <- sapply(lzoneSel, st_union)
lunion
j <- 4
lunion <- lapply(objet[i], st_union)
lunion
lunion <- NULL
lunion <- lapply(objet[i], st_union)
lunion
lunion <- NULL
lunion <- sapply(objet[i], st_union)
lunion
# parcours de l'année
sel <- objet [j]
lsel <- lapply(sel, st_union)
lsel
# parcours de la zone
lsel <- objet [j]
lselUnion <- lapply(lsel, st_combine)
lselComb <- lapply(lsel, st_combine)
lselComb
#  Pour pouvoir appliquer la fonction, on fait l'union à nouveau
# parcours de la zone
objet <- c(lzone1, lzone2, lzone3, lzone4)
j <- 4
# parcours de la zone
lsel <- objet [j]
# parcours de l'année
tot <- NULL
for (i in 1:4){
selUnion <- st_union (lsel [[i]])
tot <- rbind(tot, selUnion)
}
str(tot)
i <- 1
for (i in 1:4){
selUnion <- st_union (lsel [[i]])
tot <- rbind(tot, selUnion)
}
lzone4
i <- 1
for (i in 1:4){
selUnion <- st_union (lsel [[i]])
tot <- c(tot, selUnion)
}
str(tot)
lsel [[4]]
lzone4
lzone4 [[4]]
lzone4
lzone4 [[4]]
lsel [[4]]
lsel [[3]]
j <- 4
# parcours de la zone
lSel <- objet [j]
lSel <- NULL
# parcours de la zone
lSel <- objet [j]
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE, stringsAsFactors = FALSE)
# liste
lrpg <- split(rpg, rpg$an)
calcul <- function(data) {
aire <- sum(st_area(data))/10000
moyenne <-(sum(st_area(data)) / nrow(data))/10000
res <- c(aire, moyenne)
}
names(lrpg) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
ttsCultures <- sapply(lrpg,calcul)
st_write(rpgMais, "../dataS/chrysomele.gpkg", "rpgMais", quiet = TRUE, delete_layer = TRUE)
# uniquement mais 275 234 obs
rpgMais <- rpg [rpg$Code_cultu %in% c("MID", "MIE", "MIS"), ]
# liste
lrpgMais <- split(rpgMais, rpgMais$an)
names(lrpgMais) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
mais <- sapply(lrpgMais, calcul)
# assemblage et moyenne
total <- rbind(ttsCultures, mais)
moyenne <- apply(total,1, mean)
total <- cbind(total, moyenne)
noms <- c("tts total", "tts moy", "tts mais", "moy mais")
knitr::kable(total, digits = 2)
