---
title: "Chrysomele presentation"
author: "B. Maranget"
date: "25/01/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
    toc_float: true
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

# Cadre

## Objet

Paramètres à estimer à partir fichiers rpg sur plusieurs années pour 4 zones de l'Alsace

- taille moyenne parcelles
- SAU moyenne
- surface moyenne mais
- idem mais en monoculture
- idem mais 1e fois

difficulté : identifiant différent


Remarque : la démarche

## Librairies et répertoire

```{r}
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
library(units) # pour le pb des unités des aires. on supprime.
library(tictoc) # mesure des opérations géométriques st_union
```




## Données

### Générales

```{r}
# communes sans la corse
commune <- st_read("../dataE/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
canton2015 <- st_read("../dataE/CANTON.SHP")
fond <- st_read("../dataE/nuts.gpkg", "pays", quiet = TRUE, stringsAsFactors =F)
```


### Le rpg

2 départements concernés : Haut et Bas Rhin. Récupération sur le site de la draaf
https://draaf.grand-est.agriculture.gouv.fr/RPG,2162
https://draaf.grand-est.agriculture.gouv.fr/RPG,2161

4 années (2015 à 2018)


```{r, eval=FALSE}
# rpg dezipage
chemin <-"../dataE/rpg/"
noms <- list.files(chemin)
for (i in 1:length(noms)){
  unzip(zipfile =  paste0(chemin,noms[i]), exdir = chemin)
  # pb sous windwos
}
# assemblage
noms <- list.files(chemin, pattern = ".shp")
data <- NULL
i <- 1
for (i in 1:length(noms)){
  tmp <- st_read(paste0(chemin, noms [i]))
  tmp$an <- substring(noms [i],9,12)
  data <- rbind(data,tmp)
}
# Enregistrement en format .gpkg 972 363
rpg <- data [,c("Code_cultu", "an"), drop = FALSE]
st_write(rpg, "../dataS/chrysomele.gpkg", "rpg", row.names = FALSE,quiet = TRUE, delete_layer = TRUE)
```


#### Exploration rpg 

##### Remarque : suppression des unités m2

Les calculs d'aire génèrent automatiquement l'utilisation de la bibliothèque units.
Pour simplifier, on supprime l'unité.

```{r}
library("units")
drop_units(rpg)
```


##### Nombre d'occurences


```{r}
rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE)
tab <- addmargins(table(rpg$Code_cultu, rpg$an))
knitr::kable(tab)
```

MID / MIE / MIS mais doux, mais ensilage, mais


##### Taille moyenne des parcelles agricole

Sur l'ensemble du rpg téléchargé, 972 M obsb
en liste 929 M°, le mais 275 M°

```{r, eval = TRUE}
rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE, stringsAsFactors = FALSE)
calcul <- function(data) {
  aire <- (sum(st_area(data))/10000)/10000
  # résultat en milliers d'ha
  moyenne <-(sum(st_area(data)) / nrow(data))/10000
  res <- c(aire, moyenne)
  } 
# liste
lrpg <- split(rpg, rpg$an)
names(lrpg) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
ttsCultures <- sapply(lrpg,calcul)
# uniquement mais 275 234 obs
rpgMais <- rpg [rpg$Code_cultu %in% c("MID", "MIE", "MIS"), ]
st_write(rpgMais, "../dataS/chrysomele.gpkg", "rpgMais", quiet = TRUE, delete_layer = TRUE)
# liste
lrpgMais <- split(rpgMais, rpgMais$an)
names(lrpgMais) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
mais <- sapply(lrpgMais, calcul)
# assemblage et moyenne
total <- rbind(ttsCultures, mais)
moyenne <- apply(total,1, mean)
total <- cbind(total, moyenne)
rownames(total) <-  c("tts total", "tts moy", "mais total", "mais moy")
knitr::kable(total, digits = 1, caption = "Aires moyennes et totales (en dizaine de milliers ha) toutes cultures et mais - RPG 2019")
write.csv(total, "../dataS/totaux.csv")
```



### Zones d'étude

Les cantons d'Alsace sont réparties en 4 zones. Il s'agit des cantons d'avant 2015.

```{r, eval = FALSE}
alsace <- read.csv2("../dataE/00_ADMIN/alsace.csv")
names(alsace) <- c("zone", "PR", "nom", "CODE_CANTO")
canton2012 <- st_read("../dataE/00_ADMIN/canton2012/CANTON.SHP", quiet = TRUE, stringsAsFactors = TRUE)
str(alsace)
str(canton2012)
cantonS <- canton2015 [ canton2015$NOM_REG == "ALSACE",]
alsace.sf <- merge (cantonS, alsace, by = "CODE_CANTO")
alsace.sf <- alsace.sf [, c("CODE_CANTO", "ID_GEOFLA","zone", "PR", "nom" ),]
# cantonAlsace sera utilisé
st_write(alsace.sf, "../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, delete_layer = TRUE)
```

## Préparation des données


### Intersection zones et rpg


Les données du RPG, même pour une seule région, sont très lourdes et le R de base 
les manipule mal.

La solution est d'éclater les fichiers selon des zones géographiques et les années.

Il faut donc intersecter la zone d'étude et le rpg.

```{r}
alsace <- st_read("../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, stringsAsFactors = FALSE)
rpg <- st_read("../dataS/chrysomele.gpkg", "rpgMais", quiet = TRUE, stringsAsFactors = FALSE)
# 275 234 obs
# agrégation par zones
aggAlsace <- aggregate(alsace [,c("zone"), drop = FALSE], by = list (alsace$zone), length)
names(aggAlsace)[1:2] <- c("groupe", "nb")
png("../img/alsace.png")
par(mar=c(0,0,1.2,0))
ghostLayer(aggAlsace, bg = "lightblue1")
plot(fond, col = "antiquewhite3", border = NA, add = TRUE)
plot(dpt$geom, add = TRUE, col = "antiquewhite2", border = NA)
plot(aggAlsace$geometry, col = "antiquewhite1", border = "grey", add= TRUE)
labelLayer(aggAlsace, txt = "groupe", halo = 2 )
layoutLayer(title = "Zones d'étude Alsace")
dev.off()
# afin d'identifier les géométries, on rajoute un fid sur le rpg
rpg$id <- seq(1, nrow(rpg))
# intersection très couteuse. (359 s)
# géométrie du rpg nécessite de forcer la validité
tic()
inter <- st_intersection(st_make_valid(rpg), aggAlsace)
toc()
# modification du nom de la 4e zone
table(inter$groupe)
inter$groupe [inter$groupe == "côté Lorrain"] <- 4
# On travaillera à partir de ce fichier désormais.
st_write(inter, "../dataS/chrysomele.gpkg", "inter", quiet = TRUE, delete_layer = TRUE)
#  275 985 parcelles le rpg 275 234. Il y a donc scission des parcelles entre les différentes
# zones
nomZone <- c("zone1", "zone2", "zone3", "zone4")
```

![](../img/alsace.png)

TODO Attention zone Strasbourg absente ?

### Distribution par zone


On reprend la fonction de calcul mais cette fois sur chacune des zones.

```{r}
lzone <- split(inter, inter$groupe)
names(lzone) <- c("zone1")
# fonction pour éclater en année chacune des zones
eclaterAn <- function(df) {
  lan <- split(df, df$an)
  names(lan) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
  return(lan)
  }
lzoneAn <- lapply(lzone, eclaterAn)
total <- NULL
for (i in 1:4){
  res <- sapply(lzoneAn[[i]], calcul)
  total <- rbind(total, res)
}

# assemblage et moyenne
extr <- NULL
for (nom in nomZone){
  extr <-  c(extr,
             rep ( c(paste0("total ", nom), 
                     paste0( "moyenne " , nom))
                  )
              )
}
rownames(total) <- extr
knitr::kable(total, digits = 1, caption = "Aires moyennes et totales (en dizaine de milliers ha) par zone")
write.csv(total, "../dataS/totauxZone.csv")

```


### Cartographie des parcelles coupées 

L'enjeu est ici de détecter de possibles problèmes de géométries.

```{r}
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE)
tab <- table(inter$id, useNA = "always")
table(tab)
# c'est quoi ce zéro. et ourquoi chiffre impaire pour les doublons ?
abb <- names (tab) [is.null(tab) ]
nomSplit <- names(tab)[tab>1]
parcelleSplit <- inter [inter$id %in% nomSplit,]
png("../img/idsplit.png")
par(mar=c(0,0,1.2,0))
ghostLayer(aggAlsace, bg = "lightblue1")
plot(fond, col = "antiquewhite3", border = NA, add = TRUE)
plot(dpt$geom, add = TRUE, col = "antiquewhite2", border = NA)
plot(aggAlsace$geometry, col = "antiquewhite1", border = "grey", add= TRUE)
plot(parcelleSplit, add = TRUE)
layoutLayer(title = paste0(
                    length(nomSplit)/2,
                   " parcelles intersectées sur ", 
                   length(inter$id), " -  aire moyenne : ", 
                   round(mean(st_area(parcelleSplit))/10000,0, "ha")
                   )
            )
dev.off()
st_write(parcelleSplit,"../dataS/chrysomele.gpkg", "parcelleSplit", delete_layer=TRUE, quiet = TRUE)
plot(sort(st_area(parcelleSplit)), ylim = c(0, 50000))
abline(5000,0)
```

![](../img/idsplit.png)


### Nettoyage de la donnée spatiale

Le but est d'obtenir uniquement des polygones afin d'éviter les erreurs topologiques dans les fonctions d'intersection.

TODO vérfier par rapport aux aires totales


```{r}
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# 207 734 Nettoyer les géométries, c'est supprimer les geometrycollection, n'avoir que des polygones.
# 275 985
nettoyerGeom <- function (df) {
  df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
  dfvalid <- st_make_valid(df)
  dfpoly <- st_cast(dfvalid, "POLYGON")
}

# Supprimer les petits polygones, ceux qui sont milieu 1e classe
# à n'utiliser que si pb topologique... et même la
supprimer <- function (df) {
  df <- st_as_sf(df)
  df$aire <- drop_units(st_area(df) /10000)
  bks <- getBreaks(df$aire, nclass = 8, method ="fisher")
  df <- df [df$aire > bks [2]/2,]
  }

# Fusionner les parcelles adjacentes : union de tous les polygones, puis éclatement /
# à n'utiliser qu'après avoir extrait les couches, sinon pb années
polygoner <- function(df) {
  dfunion <- st_union(df)
  dfpoly <- st_cast(dfunion, "POLYGON")
}


# Eclater les zones et les années, car on va travailler sur la géométrie.
eclater <- function (num) {
 df <- lzone[[num]]
 ldf <- split (df, df$an)
}
# de 207 334 à 207 018
# 275578
inter <- nettoyerGeom(inter)
summary(inter$geom)
lzone <- split(inter, inter$groupe)
# boucle sur les zones
i <- 1
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
for (i in 1:4){
  # on imbrique et on nomme
    assign(noms [i], lapply(eclater (i),polygoner))
}
# on revérifie par rapport au premier calcul
total
# changement nrow pour length car il n'existe plus que la colonne géométrie
calcul2 <- function(data) {
  aire <- (sum(st_area(data))/10000)/10000
  # résultat en milliers d'ha
  moyenne <-(sum(st_area(data)) / length(data))/10000
  res <- c(aire, moyenne)
} 
tot <- NULL
for (nom in noms){
  data <- get(nom)
  res <- sapply(data, calcul2)
  tot <- rbind(tot, res)
}
tot
total - tot
# les moyennes ont toutes baissé ! alors que recherche fusion !
# 90 / 27 / 39 et 2 M°
# 115 / 34 50 2.6
# ces couches sont plus propres ?
# enregistrement en fichiers pour qgis
enregistrer <- function(df, num) {
  #  on récupère le nom de la zone et l'année sur le df même
  zone <- substring(deparse(substitute(df)),2,6)
  st_write(df, dsn = "../dataS/chrysomelexport.gpkg", 
           layer = paste0(zone,"_", num), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4){
enregistrer(lzone1 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone2 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone3 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone4 [[i]],i)
}
# pour utiliser lapply, on imbrique les listes de zone dans une liste (cet objet
# est différent du lzone)
limbrique <- list(lzone1, lzone2, lzone3, lzone4)
```


Allègement pour fin de test

```{r}
leger2 <- lapply(lzone2, supprimer)
# 34 M°OK
# 27 M° OK
```


# Fonctions permettant d'extraire les objets spatiaux prêts à l'emploi


## Rappel méthode : point sur opérateurs spatiaux

![](../img/opspatiaux.png)

Par ailleurs, on utilise des lapply

## Uniquement le maïs sur les 4 ans

Sur 4 ans, les carreaux maïs et rien d'autre. C'est l'intersection de toutes les années.
Fonction récursive.

```{r}
quatreAns <- function(l) {
  f <- length (l)
  i <- 2
  prem <- st_intersection(l[[i-1]], l [[i]])
  for (i in 2:(f-1)){
    inter <- st_intersection(prem, l[[i+1]])
  }
  aire <- round(sum(st_area(inter))/10000,2)
  aire <- drop_units(aire)
  return(aire)
}
# test sur petite zone
res <- quatreAns(lzone4)
library("units")
res <-  drop_units(res)
# test sur la liste imbrique
tic()
maisUnique <- sapply(limbrique, quatreAns)
toc()
# stockage du résultat 34 s 
# autre test 45 s
# rapport au total
names(maisUnique) <- nomZone
maisUnique <- as.data.frame(maisUnique)
maisUnique
write.csv(maisUnique, "../dataS/res.csv")
```

Les intersections fonctionnent, même sur des gros fichiers.


## Uniquement mais sur une année

On crée une fonction ayant pour paramètre la zone concernée et l'année de la demande.
On reste d'abord sur la structure de liste.

```{r, eval=TRUE}
lunion <- lzone2
num <- 1
anneeUnique <- function(lunion, num) {
  X <- st_union(lunion [[num]] ) %>% st_set_precision(100000) %>% st_make_valid()
  # la précision génère des erreurs topologiques
  lreste <- lunion
  lreste [[num]] <- NULL
  # on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
  # créer une seule table
  tot <- NULL
  for (i in 1:3) {
    g <- lreste[[i]][, 1, drop = TRUE]
    tot <- c(tot,g)
  }
  # objet sf et crs
  tot <- st_as_sf(st_as_sfc(tot))
  st_crs(tot) <- 2154
  Y <- st_union(tot) %>% st_set_precision(100000) %>% st_make_valid()
  res <- st_difference(X, Y)
  res <-round(st_area(res)/10000,0)
  res <- drop_units(res)
}
```


```{r, eval=TRUE}
# test sur petite zone
# le Y est à 227 M ° puis 
tic()
tot <- NULL
for (i in 1:4) {
  res <- anneeUnique(lzone4,i)
  tot <- c(tot,res)
}
toc()
reszone4 <- tot
# 11 s
# l'appel à la fonction totale serait
tic()
reszone4 <- sapply(1:4, function(i){anneeUnique(lzone2,i)})
toc()
# 581 s , 5 600s
# 34.4 M0 et 50 M°
reszone1 <- NA
reszone2 <- c(2044, 1054  ,927, 1135)
reszone3 <- c(2183, 1731, 1532, 1387)
# pour la 1 14558 erreur, on met la précision très bas - 100, erreur quand meme
# allègement des données nécessaires.
# enregistrement dans le tableau res
nomTab <- c("annéeUnique1","annéeUnique2", "annéeUnique3", "annéeUnique4")
res <- cbind(reszone1, reszone2, reszone3, reszone4)
colnames(res) <- nomTab
dataf <- cbind(maisUnique, res)
write.csv(dataf, "../dataS/res.csv")
```




```{r}
zone4anneUnique <- c(691,  773 ,1019 , 804)
# 2 mn pour une zone de 2.4  77 s
tic()
tot <- NULL
for (i in 1:4) {
  res <- anneeUnique(lzone2,i)
  tot <- c(tot,res)
}
toc()
# zone de 27 M° 1135
zone2anneeUnique <- c( 2044, 1054,  927, 1135)
tic()
tot <- NULL
for (i in 1:4) {
  res <- anneeUnique(lzone3,i)
  tot <- c(tot,res)
}
toc()
```


# Nouvelle méthode : R + QGIS

On enregistre les fichiers nécessaires sans utiliser et on fait la différence sous QGIS.
Puis on importe les résultats dans R a afin de faire les tableaux.
Du coup, on transforme les 3 fonctions (la première avec les st_intersection rend un résultat)
Au lieu d'utiliser les listes, il est plus simple de repartir de la base.


## annee unique

```{r}
df <- zone2
num <- 1
# plus simple de repartir d'inter !
enregistrerAnneeUnique <- function(df, num) {
  # récupération du nom pour nommer le fichier, df reste l'objet
  an <-  c("2015", "2016","2017","2018")
  X <- df [df$an == an [num] , ]
  Y <- df [df$an !=  an [num],]
  nomZone <-  df$groupe [1]
  # obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
  nomgpkg <- paste0("../dataS/chrysomelexport",nomZone,".gpkg")
  st_write(X, dsn = nomgpkg, layer = paste0(nomZone,"_", an[num]), quiet = TRUE, delete_layer = TRUE)
  st_write(Y, dsn = nomgpkg, layer = paste0(nomZone,"_autres_", an [num]), quiet = TRUE, delete_layer = TRUE)
}
```




Enregistrement des données pour Qgis

Pour chaque année, deux couches, celle de l'année X et celle de toutes les années Y.

```{r}
#boucle pour les zones
i <- 1
for (i in 1:4) {
  df <-  inter [inter$groupe == i,] 
  j <- 1
    # boucle pour les années
  for (j in 1:4) {
    enregistrerAnneeUnique(df, j)
  }
}
```


On récupère la couche de différence

```{r, eval = TRUE}
couche <- c("2015", "2016", "2017", "2018")

totalfin <- NULL
j <- 1
for (j in 1:4) {
  i <- 1
  total <- NULL
  # boucle année
  for (i in 1:4) {
    nom <- paste0("../dataS/chrysomelediff", j, "_", couche [i], ".gpkg")
    print(nom)
    diff <- st_read(nom,  quiet = TRUE)
    total <- rbind(total, sum(st_area(diff)))
    names(total) <- paste0("an ", i)
  }
  #rownames(total) <- couche [i]
  total <- round(total / 10000, 0)
  totalfin <-  cbind(total, totalfin)

}
totalfin
dataf
noms <- c("idemQGIS4", "idemQGIS3", "idemQGIS2", "idemQGIS1")
colnames(totalfin) <-  noms
dataf <-  cbind(dataf, totalfin)
write.csv(dataf, "../dataS/res.csv")
```




## Deux ans


```{r, eval=TRUE}
enregistrerDeuxAns <- function (df) {
  nomZone <-  df$groupe [1]
  print(nomZone)
  # choix des paires dans 4 elements
  nb <- 2
  els <- seq (1:4)
  i <- 2
  for (i in 2:4) {
    paire <- c(1, i)
    nomPaire <- paste0(paire[1], paire[2])
    print (nomPaire)
    an <-  c("2015", "2016", "2017", "2018")
    X <- df   [df$an %in% an[paire], ]
    Y <- df [!df$an %in% an[paire], ]
    nomgpkg <-
      paste0("../dataS/chrysomelexportDeux", nomZone, ".gpkg")
    st_write(
      X,
      dsn = nomgpkg,
      layer = paste0(nomZone, "_", nomPaire),
      quiet = TRUE,
      delete_layer = TRUE
    )
    st_write(
      Y,
      dsn = nomgpkg,
      layer = paste0(nomZone, "_autres_", nomPaire),
      quiet = TRUE,
      delete_layer = TRUE
    )
  }
  
}


# sur chaque zone
for (i in 1:4) {
  enregistrerDeuxAns(inter [inter$groupe == i,])
}

```


## Trois ans

```{r}
enregistrerTroisAns <- function (df) {
  nomZone <-  df$groupe [1]
  print(nomZone)
  # choix des paires dans 4 elements
  els <- seq (1:4)
  i <- 1
  for (i in 1:4) {
    nbY <- i 
    nbX <- els [-i]
    nomX <- paste0(nbX[1],nbX[2], nbX[3])
    an <-  c("2015", "2016", "2017", "2018")
    an [nbX]
    X <- df   [df$an %in% an[nbX], ]
    Y <- df [df$an %in% an[nbY], ]
    nomgpkg <-
      paste0("../dataS/chrysomelexportTrois", nomZone, ".gpkg")
    st_write(
      X,
      dsn = nomgpkg,
      layer = paste0(nomZone, "_", nomX),
      quiet = TRUE,
      delete_layer = TRUE
    )
    st_write(
      Y,
      dsn = nomgpkg,
      layer = paste0(nomZone, "_autres_", nomX),
      quiet = TRUE,
      delete_layer = TRUE
    )
  }
  
}

# sur chaque zone
for (i in 1:4) {
  enregistrerTroisAns(inter [inter$groupe == i,])
  }
```


# Extraction 3 ans

```{r, eval = TRUE}
total <- NULL
totalZone <- NULL
noms <- NULL
i <- 1
#parcours des zones
for (i in 1:4) {
 print(i)
  # parcours des années
  for (j in c(123,124,134,234)){
  nomfic <- paste0("../dataS/chrysomelediff", i,"_",j, ".gpkg")
  nomcouche <- paste0("chrysomelediff", i,"_",j)
  diff <-
    st_read(nomfic,
            layer = nomcouche,
            quiet = TRUE)
    total <- rbind(total,sum(st_area(diff)))
  }
   colnames(total) <- i
   total <- round(total/10000,0)
   totalZone <-  cbind(totalZone, total)
   total <- NULL
}
rownames(totalZone) <- c(123,124,134,234)

# total des différences années et autres années (aires en ha)
totalTrois <- totalZone
totalZone
```

# Extraction 2 ans



```{r, eval = TRUE}
total <- NULL
totalZone <- NULL
noms <- NULL
i <- 1
#parcours des zones
for (i in 1:4) {
 print(i)
  # parcours des années
  for (j in c(12,13,14)){
  nomfic <- paste0("../dataS/chrysomelediff", i,"_",j, ".gpkg")
  nomcouche <- paste0("chrysomelediff", i,"_",j)
  diff <-
    st_read(nomfic,
            layer = nomcouche,
            quiet = TRUE)
    total <- rbind(total,sum(st_area(diff)))
  }
   colnames(total) <- i
   total <- round(total/10000,0)
   totalZone <-  cbind(totalZone, total)
   total <- NULL
}
rownames(totalZone) <- c(12,13,14)

# total des différences années et autres années (aires en ha)
totalDeux <- totalZone
```

fichier final
```{r}
fin <- rbind (totalDeux, totalTrois)
fin
write.csv(fin, "../dataS/chrysomeleTotal.csv")
```

