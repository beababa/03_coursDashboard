# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
library(units) # pour le pb des unités des aires. on supprime.
library(tictoc) # mesure des opérations géométriques st_union
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = TRUE)
# Nettoyer les géométries, c'est supprimer les geometrycollection
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(dfvalid, "POLYGON")
}
# Fusionner les parcelles adjacentes : union de tous les polygones, puis éclatement
polygoner <- function(df) {
dfunion <- st_union(df)
dfpoly <- st_cast(dfunion, "POLYGON")
}
# Eclater les zones et les années, car on va travailler sur la géométrie.
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
}
# de 207 334 à 207 018
inter <- nettoyerGeom(inter)
summary(inter$geom)
lzone <- split(inter, inter$groupe)
# boucle sur les zones
i <- 1
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
for (i in 1:4){
leclate <- eclater (i)
# lapply  sur les années
lpoly <- lapply(leclate,polygoner)
assign(noms [i], lpoly)
}
# 90 / 27 / 39 et 2 M°
# enregistrement en fichiers pour qgis
enregistrer <- function(df, num) {
#  on récupère le nom de la zone et l'année sur le df même
zone <- substring(deparse(substitute(df)),2,6)
st_write(df, dsn = "../dataS/chrysomelexport.gpkg",
layer = paste0(zone,"_", num), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4){
enregistrer(lzone1 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone2 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone3 [[i]],i)
}
for (i in 1:4){
enregistrer(lzone4 [[i]],i)
}
# pour utiliser lapply, on imbrique les listes de zone dans une liste (cet objet
# est différent du lzone)
limbrique <- list(lzone1, lzone2, lzone3, lzone4)
lunion <- lzone2
num <- 1
X <- st_as_sf(st_union(lunion [[num]]))
X
st_crs(X) <- 2154
X
X <- polygoner(X)
X
X <- st_union(X)
X <- st_as_sf(st_union(lunion [[num]]))
st_crs(X) <- 2154
X <- polygoner(X)
X <- st_union(X)
X <- st_make_valid(X)
X <- st_as_sf(st_union(lunion [[num]]))
st_crs(X) <- 2154
X <- polygoner(X)
X <- st_make_valid(X)
X <- st_union(X)
# objet multipolygon
# st_crs(X) lambert 93
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_make_valid(Y)
Y <- st_make_valid(tot)
Y <- st_as_sf(st_union(Y))
Y <- (st_union(Y))
Y <- st_make_valid(Y)
res <- st_difference(X, Y)
lunion <- lzone2
num <- 1
X <- st_as_sf(st_union(lunion [[num]]))
st_crs(X) <- 2154
X <- polygoner(X)
X <- st_union(X)
X <- st_make_valid(X)
X <- st_buffer(X,0)
# objet multipolygon
# st_crs(X) lambert 93
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_make_valid(tot)
Y <- st_buffer(Y,0)
Y <- (st_union(Y))
# sfc
st_crs(Y)
# sfc
st_crs(X)
res <- st_difference(X, Y)
#X <- st_as_sf(st_union(lunion [[num]]))
X <- lunion [[1]]
res <- st_difference(X, Y)
X <- st_buffer(X,0)
Y <- st_buffer(Y,0)
res <- st_difference(X, Y)
df <- zone2
# on repart des enregistrements
for (i in 1:4) {
assign(paste0("zone_",i), st_read ("chrysomelexport.gpkg", paste0("zone2_",i), quiet = TRUE))
}
assign(paste0("zone_",i), st_read ("../dataS/chrysomelexport.gpkg", paste0("zone2_",i), quiet = TRUE))
# on repart des enregistrements
for (i in 1:4) {
assign(paste0("zone_",i), st_read ("../dataS/chrysomelexport.gpkg", paste0("zone2_",i), quiet = TRUE))
}
l <- list(zone_1, zone_2, zone_3, zone_4)
df <- inter [inter$groupe == 2,]
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
Xunion <- st_union(X)
# L'union peut se faire sous R quand même non ?
Y <- (st_union(Y))
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
table(inter$groupe)
noms <- names(table(inter$groupe))
# modification du nom de la 4e zone
table(inter$groupe)
inter$groupe [inter$groupe == "côté Lorrain"] <- 4
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# modification du nom de la 4e zone
table(inter$groupe)
inter$groupe [inter$groupe == "côté Lorrain"] <- 4
# On travaillera à partir de ce fichier désormais.
st_write(inter, "../dataS/chrysomele.gpkg", "inter", quiet = TRUE, delete_layer = TRUE)
# modification du nom de la 4e zone
table(inter$groupe)
# plus simple de repartir d'inter !
df <- inter [inter$groupe == 2,]
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- (st_union(Y))
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
# plus simple de repartir d'inter !
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- st_union(Y)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
#boucle pour les zones
for (i in 1:4) {
assign(paste0("zone",i), inter [inter$groupe == i] )
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(paste0("zone",i), j)
}
}
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i] )
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i,] )
#boucle pour les zones
i <- 1
for (i in 1:4) {
assign(paste0("zone",i), inter [inter$groupe == i,] )
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(paste0("zone",i), j)
}
}
memory.size()
memory.limit(4000)
memory.limit(3000)
memory.limit(2000)
memory.limit(1000)
memory.size()
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i,] )
nom <- paste0("zone",i)
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(nom, j)
}
zone <- deparse(substitute(zone2))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- st_union(Y)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
# plus simple de repartir d'inter !
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
X <- st_union(X)
Y <- st_union(Y)
#res <- st_difference(Xunion,Yunion )
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
#boucle pour les zones
i <- 1
for (i in 1:4) {
assign(paste0("zone",i), inter [inter$groupe == i,] )
nom <- paste0("zone",i)
# boucle pour les années
for (j in 1:4) {
enregistrerAnneeUnique(nom, j)
}
}
#boucle pour les zones
i <- 1
assign(paste0("zone",i), inter [inter$groupe == i,] )
nom <- paste0("zone",i)
j <- 1
enregistrerAnneeUnique(nom, j)
anneeUnique <- function(lunion, num) {
X <- st_union(lunion [[num]] ) %>% st_set_precision(1000000) %>% st_make_valid()
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1, drop = TRUE]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_union(tot) %>% st_set_precision(1000000) %>% st_make_valid()
res <- st_difference(X, Y)
res <-round(st_area(res)/10000,0)
res <- drop_units(res)
}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
library(units) # pour le pb des unités des aires. on supprime.
library(tictoc) # mesure des opérations géométriques st_union
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# 207 734 Nettoyer les géométries, c'est supprimer les geometrycollection, n'avoir que des polygones.
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(dfvalid, "POLYGON")
}
# Supprimer les petits polygones, ceux qui sont milieu 1e classe
# à n'utiliser que si pb topologique... et même la
supprimer <- function (df) {
df <- st_as_sf(df)
df$aire <- drop_units(st_area(df) /10000)
bks <- getBreaks(df$aire, nclass = 8, method ="fisher")
df <- df [df$aire > bks [2]/2,]
}
# Fusionner les parcelles adjacentes : union de tous les polygones, puis éclatement
polygoner <- function(df) {
dfunion <- st_union(df)
dfpoly <- st_cast(dfunion, "POLYGON")
}
# Eclater les zones et les années, car on va travailler sur la géométrie.
eclater <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
}
# de 207 334 à 207 018
inter <- nettoyerGeom(inter)
summary(inter$geom)
lzone <- split(inter, inter$groupe)
# boucle sur les zones
i <- 1
noms <- c("lzone1", "lzone2", "lzone3","lzone4")
for (i in 1:4){
# on imbrique et on nomme
assign(noms [i], lapply(eclater (i),polygoner))
}
leger2 <- lapply(lzone2, supprimer)
lunion <- lzone2
num <- 1
anneeUnique <- function(lunion, num) {
X <- st_union(lunion [[num]] ) %>% st_set_precision(1000000) %>% st_make_valid()
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1, drop = TRUE]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_union(tot) %>% st_set_precision(1000000) %>% st_make_valid()
res <- st_difference(X, Y)
res <-round(st_area(res)/10000,0)
res <- drop_units(res)
}
tic()
res <- sapply(1:4, function(i){anneeUnique(lzone2,i)})
toc()
# 581 s
res
tic()
res <- sapply(1:4, function(i){anneeUnique(lzone3,i)})
toc()
# 581 s
res
tic()
res <- sapply(1:4, function(i){anneeUnique(lzone1,i)})
toc()
anneeUnique <- function(lunion, num) {
X <- st_union(lunion [[num]] ) %>% st_set_precision(10000) %>% st_make_valid()
lreste <- lunion
lreste [[num]] <- NULL
# on unit les 3 années. mais le st_union fait produit cartésien. il faut d'abord
# créer une seule table
tot <- NULL
for (i in 1:3) {
g <- lreste[[i]][, 1, drop = TRUE]
tot <- c(tot,g)
}
# objet sf et crs
tot <- st_as_sf(st_as_sfc(tot))
st_crs(tot) <- 2154
Y <- st_union(tot) %>% st_set_precision(1000000) %>% st_make_valid()
res <- st_difference(X, Y)
res <-round(st_area(res)/10000,0)
res <- drop_units(res)
}
tic()
res <- sapply(1:1, function(i){anneeUnique(lzone1,i)})
toc()
# sur chaque zone sauf la une
tic()
res2 <- troisAns(inter [inter$groupe == 2,])
troisAns <- function (df) {
nomZone <-  df$groupe [1]
print(nomZone)
# choix des paires dans 4 elements
els <- seq (1:4)
i <- 1
for (i in 1:4) {
nbY <- i
nbX <- els [-i]
nomX <- paste0(nbX[1],nbX[2], nbX[3])
an <-  c("2015", "2016", "2017", "2018")
an [nbX]
X <- df   [df$an %in% an[nbX], ]
Y <- df [df$an %in% an[nbY], ]
X <- polygoner(X)  %>%  st_union() %>% st_set_precision(100000) %>% st_make_valid()
Y <- polygoner(Y) %>% st_union(X) %>% st_set_precision(100000) %>% st_make_valid()
res <- st_area(st_difference(X,Y))/10000
tot <- c(tot, res)
}
return(tot)
}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
library(units) # pour le pb des unités des aires. on supprime.
library(tictoc) # mesure des opérations géométriques st_union
library(mapview)
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# Fusionner les parcelles adjacentes : union de tous les polygones, puis éclatement /
# à n'utiliser qu'après avoir extrait les couches, sinon pb années
polygoner <- function(df) {
dfunion <- st_union(df)
dfpoly <- st_cast(dfunion, "POLYGON")
}
# 207 734 Nettoyer les géométries, c'est supprimer les geometrycollection, n'avoir que des polygones.
# 275 985
nettoyerGeom <- function (df) {
df <-df [st_geometry_type(df) != "GEOMETRYCOLLECTION",]
dfvalid <- st_make_valid(df)
dfpoly <- st_cast(dfvalid, "POLYGON")
}
# de 207 334 à 207 018
# 275578
inter <- nettoyerGeom(inter)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
# Chunk 2
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(lwgeom) # pour la validation de la géométrie
library(cartography)
library(units) # pour le pb des unités des aires. on supprime.
library(tictoc) # mesure des opérations géométriques st_union
library(mapview)
# Chunk 3
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
canton2015 <- st_read("../dataE/00_ADMIN/canton2015/CANTON.SHP")
fond <- st_read("../dataE/00_ADMIN/nuts.gpkg", "pays", quiet = TRUE, stringsAsFactors =F)
# rpg dezipage
chemin <-"../dataE/01_CULTURES/rpg/"
noms <- list.files(chemin)
for (i in 1:length(noms)){
unzip(zipfile =  paste0(chemin,noms[i]), exdir = chemin)
}
# assemblage
noms <- list.files(chemin, pattern = ".shp")
data <- NULL
i <- 1
for (i in 1:length(noms)){
tmp <- st_read(paste0(chemin, noms [i]))
tmp$an <- substring(noms [i],9,12)
data <- rbind(data,tmp)
}
# champs rpg
code <- table(data$Code_cultu)
code
# champs rpg
code <- sort(table(data$Code_cultu))
code
knitr:kabel(code)
knitr::kable(code)
st_write(rpg, "../dataS/chrysomele.gpkg", "rpg", row.names = FALSE,quiet = TRUE, delete_layer = TRUE)
# Enregistrement en format .gpkg 972 363
rpg <- data [,c("Code_cultu", "an"), drop = FALSE]
st_write(rpg, "../dataS/chrysomele.gpkg", "rpg", row.names = FALSE,quiet = TRUE, delete_layer = TRUE)
