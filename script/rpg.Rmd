---
title: "RPG"
author: "B. Maranget"
date: "08/01/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

# Cadre

## Objet

agréger contenu rpg de parcelles à canton
cartographier mais doux

## Librairies et répertoire

```{r}
library(sf)
library(cartography)
```

# Données

```{r}
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
region <- st_read("../dataE/00_ADMIN/ign.gpkg", "region", quiet = TRUE, stringsAsFactors =F)
# Ouverture des 100 premières lignes de fichier des parcelles
dataTest <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", 
	query = 'SELECT * FROM "parcelle_graphique" LIMIT 100' )
# liste des variables culture année 2017 (ancien fichier résultat)
culture <- read.csv("../dataE/01_CULTURES/culture.csv", header = FALSE, stringsAsFactors = FALSE)
culture <- culture$V1
# 297 colonnes 280 d'origigine et rajout col avec 8 
canton2015 <- st_read("../dataE/00_ADMIN/CANTON.SHP")
```


# Récupération des données du fichier des parcelles

## Ouverture

Le fichier comporte 9 millions de parcelles, il ne s'ouvre pas en totalité sous R.

On pourrait l'ouvrir via une boucle sur chaque code culture

```{r, eval=FALSE}
i <- 1
query_str <- paste0('SELECT ID_PARCEL, geom FROM "parcelle_graphique" WHERE CODE_CULTU = "', culture [i], "\"") 
data <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", query = query_str)
inter <- st_intersection(canton2015 [,"CODE_CANT"], data [,"ID_PARCEL"])
```

On pourrait l'ouvrir sans la géométrie


```{r, eval = FALSE}
#  téléchargement du fichier sans la géomtrie
dataSansGeom <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique",
  query = 'SELECT  ID_PARCEL , CODE_CULTU , CODE_GROUP FROM "parcelle_graphique" ' )
```

On préfère mettre en place une base postgis et on fait l'agregation dedans.


```SQL
CREATE TABLE data2019 AS (
SELECT canton.fid, canton.id_geofla,code_cultu, sum(surf_parc)  AS surface
FROM parcelle_graphique, canton
	WHERE ST_INTERSECTS(st_centroid(parcelle_graphique.geom), canton.geom)
	GROUP BY code_cultu, canton.fid
	);
```


TODO attaquer la base postgis depuis R
Essayé : traitement des guillemets est complexe




TODO explorer diply et sqlite


La table contient donc toutes les données du fichier. Pour alléger, on a enlevé 
les géométries à l'export mais l'intersection s'est fait sur les géométries
L'identifiant  (fid) correspond au rang des cantons de 1 à 
Le geofla permet de valider le fid



## Création d'un identifiant unique et simple (ID_GEOFLA trop complexe)

```{r}
data <- read.csv("../dataS/data2019.csv", sep = "\t", dec = ".", header  = FALSE)
#  106 660 lg
names(data) <- c("ID_CANTON", "ID_GEOFLA", "CULTURE", "SURFACE")
table(data$CULTURE)

```

TODO pourquoi cette multiplicité d'identifiants ?

Attention le Code_canto et CODE_CANT ne sont pas des identifiants uniques !

```{r}
max(table(canton2015$Code_canto))
max(table(canton2015$CODE_CANT))
max(table(canton2015$ID_GEOFLA))
# l'id canton correspond à un numéro incrementé dans la base postgis de 1 à 2378
# il correspond pas aux 4 derniers caractères de l'id geofla (max canton 2378)
data$Sub_ID_GEOFLA <- as.integer(substring(data$ID_GEOFLA, 21,24))
data[!(data$Sub_ID_GEOFLA == data$ID_CANTON),]
```

id_canton correspond aux derniers chiffres de l'id_geofla

```{r}
canton2015$ID_CANTON <- as.integer(substring(canton2015$ID_GEOFLA, 21,24))
```

## Calcul de la SAU pour toutes les cultures pour chaque canton

```{r}
SAU <-  aggregate(data$SURFACE, by = list (data$ID_CANTON), sum)
names(SAU) <- c("ID_CANTON", "SAU_HA")
canton2015b <- merge(canton2015, SAU, by = "ID_CANTON")
# 2281 cantons avec une SAU contre 2378 cantons au total
diff <- setdiff(canton2015$ID_CANTON,canton2015b$ID_CANTON)
cantondiff <- canton2015 [canton2015$ID_CANTON %in% diff,]


# canton 2015, région avant 2016, donc on intersecte pour récupérer les nouvelles régions
regionS <- st_intersection(region, cantondiff)
regS <- unique(regionS$NOM_REG)
deptS <- st_intersection(dpt, cantondiff)
# 1 region iles de france + 8 dpts
dptS <- unique(deptS$NOM_DEP[deptS$INSEE_REG !=11])
fond1 <- region [region$NOM_REG == "ILE-DE-FRANCE", "NOM_REG"] 
fond2 <- dpt [dpt$NOM_DEP %in% dptS, "NOM_DEP"]
names(fond1)[1] <- "NOM"
names(fond2)[1] <- "NOM"
fond <- rbind(fond1, fond2)
#png("img/cantonsansculture.png")
par(mfrow = c(3,3))
for (i in 1:9){
  par(mar = c(0,0,1.2,0))
  ghostLayer(fond$geom [i], bg = "lightblue2")
  plot(region$geom, col = "antiquewhite1", border = "white", add = TRUE)
  plot(fond$geom [i], col = "antiquewhite2", border = "white", add = TRUE)
  plot(cantondiff$geometry, add = TRUE, col= "red", border = NA)
  layoutLayer(fond$NOM [i])
}
#dev.off()
canton2015 <- canton2015b
```


Il y 97 cantons sans culture.

TODO analyse canton sans culture ?

TODO pb surface bio inclu dans SAU ?

## Vérification import données

Pour vérification, on va extraire de la table le CAE via R


```{r, eval= FALSE}
cae <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", 
	query = 'SELECT * FROM "parcelle_graphique" WHERE CODE_CULTU = "CAE"')
st_write(cae, "../dataS/rpg.gpkg", "cae", delete_layer = TRUE, quiet = TRUE)
head(cae)
cae.c <- st_centroid(cae)
caeCantonInter <- st_intersection(cae, canton2015)
nrow(caeCantonInter) - nrow(cae)
# 41 morceaux de parcelles sur 2634.
str(caeCantonInter)
# verif des aires
caeCantonInter$aire <- round(st_area(caeCantonInter)/10000,2)
caeCantonInter$aire <- as.numeric(caeCantonInter$aire)
caeCantonInter$verif <- caeCantonInter$SURF_PARC - caeCantonInter$aire
plot((caeCantonInter$verif))
# 91 aires différentes
caeCantonAire <-caeCantonInter [, c("aire", "ID_GEOFLA"), drop = FALSE]
caeCantonAgg <- aggregate(aire~ID_GEOFLA,caeCantonAire, sum)
# on rattache les géométries des cantons.
caeData <- merge(caeCantonAgg, canton2015, by = "ID_GEOFLA")
caeData <- st_as_sf(caeData)
choroLayer(caeData, var ="aire")
st_write(caeData, "../dataS/rpg.gpkg", "verifCAE", quiet = TRUE, delete_layer = TRUE)

dataCAE <- data [data$CULTURE == "CAE",]

st_write(dataCAE, "../dataS/rpg.gpkg", "baseCAE", quiet = TRUE, delete_layer = TRUE)
```


Il y a de légères différences dûes à l'utilisation du centroid dans la requete sql.


TODO vérification sur les quantités totales de culture




# Catégories de culture

## Problème : pas toutes les variables dans le rpg 2019

```{r}
dataCulture <- names (table(data$CULTURE))
diff <- setdiff(culture, dataCulture)
# exclusion 10 codes
setdiff(dataCulture, culture)
cultureDef <- intersect(culture,dataCulture)
# cultureDef représente les champs présents dans les deux tables (231)
# on filtre ensuite sur les cultures nécessaires uniquement
dataFiltre <- data [data$CULTURE %in% cultureDef,]
# 103 430 lg. -3 000 c'est toujours bon à prendre 
```


## Vérification code culture possible entre fichier sans geom et lien


```{r, eval = FALSE}
#  téléchargement du fichier sans la géomtrie
dataSansGeom <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique",
  query = 'SELECT  ID_PARCEL , CODE_CULTU , CODE_GROUP FROM "parcelle_graphique" ' )
cultureSansGeom <- names(table(dataSansGeom$CODE_CULTU))
setdiff(cultureSansGeom, vCulture)
```

Donc les données sont sûres....

# Mise en forme des données

Le tableau final comporte une transposition de la colonne en ligne.

## Transpostion données colonne ligne

```{r}
# création df nb de lg = nb de cantons et nb de col = nb de cultures + idCanton
df <- data.frame(matrix
                    (vector(),
                    2281,232,
                    dimnames = list(c(), c("ID_CANTON",cultureDef))
                    ),
                 stringsAsFactors = F)
df$ID_CANTON <- canton2015$ID_CANTON 
# parcours de dataFiltre
nb <- length(dataFiltre$ID_CANTON)
i <- 1
for (i in 1:nb) {
  surface <- dataFiltre$SURFACE [i]
  canton <- dataFiltre$ID_CANTON [i]
  culture <- dataFiltre$CULTURE [i]
  df [df$ID_CANTON == canton ,  culture] <- surface
}
# verif : compter les totaux
sum(df [,-1], na.rm = TRUE)
sum(dataFiltre$SURFACE)
```


##  Fusion avec colonnes finales

```{r}
# on fait la jointure avec les géométries des cantons
dfFusion <- merge(canton2015, df, by = "ID_CANTON")
# 2281
# pour fichier final
col <- c("ID_CANTON", "ID_GEOFLA","Code_canto",  "NOM_CHF", "CODE_DEPT", "NOM_DEPT", "CODE_REG","NOM_REG", "CODE_CANT", "SAU_HA", cultureDef)
dfFusion <- dfFusion [, col]
st_write(dfFusion, "../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, delete_layer = TRUE)
# export des données alpha numériques uniquement
dfSansGeom <- dfFusion [, col, drop = TRUE]
write.csv2(dfSansGeom, "../dataS/dataFinale.csv", na = "" , row.names = FALSE)
# 2281 lignes
```


## Extraction des données à cartographier

MD 2017	MD 2018	MD 2019	MD / TA	MD / surf tot	MD/surf M	MD/légumes

l'extraction s'est faite sous excel mais j'ai toujours le pb de l'identifiant unique.


```{r}
data <- read.csv2("../dataE/01_CULTURES/extraction.csv")
data.sf <-  merge(canton2015, data, by = "CODE_CAN")
names(data)
names(canton2015)
unique(data$Code_canto)
length(unique(canton2015$Code_canto))
# 1972 code canton pour 2378 lignes dans le fichier canton
```

Impossible de faire la jointure puisqu'il y a un problème d'identifiant unique.
On repart de la totalité de la donnée.

```{r}
data <- st_read("../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, stringsAsFactors = FALSE)
names(data)
sum(dataSel$MID, na.rm = TRUE )
code <- read.csv2("../dataE/01_CULTURES/code_culture.csv", stringsAsFactors = FALSE)
# filtrage sur MP et Aquitaine
table(data$NOM_REG)
dataSel <- data [data$NOM_REG %in% c("MIDI-PYRENEES", "AQUITAINE"),]
# 323 cantons concernés
# calcul des agregats
# TA
codeTA <- code$Code.Culture[code$TA == "Oui"]
coderpg <- names(data) [9:239]
tail(coderpg)
# verif BTH jusqu'à TRU
codeTA2 <- intersect(codeTA, coderpg)
# mais
codeMais <- code$Code.Culture[code$Maïs == "Oui"]
codeMais2 <- intersect(codeMais, coderpg)
# Légumes
codeLegume <- code$Code.Culture[code$Légumes == "Oui"]
codeLegume2 <- intersect(codeLegume, coderpg)
# rajout mais dans légumes
codeLegume2 <- c("MID", codeLegume2)
# différences entre codes totaux et codes utilisés
dataSel$TA <- rowSums(dataSel [, codeTA2, drop = TRUE], na.rm = TRUE)
dataSel$Mais <- rowSums(dataSel [, codeMais2, drop = TRUE], na.rm = TRUE)
dataSel$Legume <- rowSums(dataSel [, codeLegume2, drop = TRUE], na.rm = TRUE)
# rapports pour les données de seleciton
dataSel$ratio_MID_TA <- (dataSel$MID/dataSel$TA)*100
dataSel$ratio_MID_Mais <- (dataSel$MID/dataSel$Mais)*100
dataSel$ratio_MID_Legume <- (dataSel$MID/dataSel$Legume)*100
dataSel$ratio_MID_SAU <- (dataSel$MID/dataSel$SAU_HA)
# vérif avec totaux
colSums(dataSel[, c("TA", "Mais", "Legume", "SAU_HA"), drop = TRUE, na.rm = TRUE])
# décalage avec tab excel en TA et SAU 
idcol <- grep( "ratio",names(dataSel))
colSums(dataSel [,idcol, drop = TRUE], na.rm = TRUE)
# export pour carto
st_write(dataSel  [,c("MID",names(dataSel)[idcol])], "../dataS/rpg.gpkg", "dataCarte", quiet = TRUE, delete_layer = TRUE)
```


# Cartographie

```{r}
data <- st_read("../dataS/rpg.gpkg", "dataCarte", quiet = TRUE, stringsAsFactors = FALSE)
noms <- names(data)
bksAire <- c(0,50,150,300,500,1000, 6000)
bksMais <- c(0,10,20,30,40)
bksLegume <- c(0,20,40,60,80,100)
data$ratio_MID_SAU <- data$ratio_MID_SAU * 100
bksSAU <- c(0,5,10,15,20,25)
bksTA <- bksSAU
lbks <- list(bksAire,bksTA, bksMais, bksLegume,bksSAU)
palettes <- c("taupe.pal","blue.pal", "purple.pal", "green.pal", "red.pal")
nbcl <- c(6,5,4,5,5)
titreLegende <- c("aire (ha)", rep("ratio (%)",4))
titreCarte <- c("Surface maïs doux", "Rapport maïs et terre arable (TA)", "Rapport maïs doux et maïs",
                "Rapport maïs et légume", "Rapport maïs et SAU")
```

```{r}
i <- 1
for (i in 1:5) {
  sizes <- getFigDim(x = data, width = 3000, mar = c(0,0,1.2,0), res = 500)
  png(paste0("../img/rpg",i , ".png"), height = sizes [2], width = sizes [1], res = 500)
  par(mar = c(0,0,1.2,0))
  my.pal <- carto.pal(palettes [i], nbcl [i])
  ghostLayer(data, bg = "lightblue1")
  plot(canton2015$geom, col = "antiquewhite2", border = NA,add = TRUE)
  choroLayer(data, var = noms [i], 
             legend.title.txt = titreLegende [i], legend.pos = "topright",
             breaks = lbks [[i]], col = my.pal, nclass = nbcl [i] , border = "antiquewhite3", add = TRUE)
  layoutLayer(title = titreCarte [i], author = "Arvalis 2020", sources = "RPG 2019", horiz = FALSE,
              posscale = "bottomleft", theme = palettes [i])
  dev.off()
}


```


# Chiffres 2017 et 2018 pour le maïs doux

## Essais St_read non concluants sur du shape...

```{r}
# verif en tête
dataTest <- st_read("../dataE/01_CULTURES/rpg2018/PARCELLES_GRAPHIQUES.shp",
	query = "SELECT ID_PARCEL, CODE_CULTU FROM \"PARCELLES_GRAPHIQUES\" 
                    WHERE CODE_CULTU LIKE ORH" )
dataTest
query_str <- 'SELECT ID_PARCEL, CODE_CULTU, _ogr_geometry_ FROM "parcelle_graphique" 
                    WHERE CODE_CULTU = 'MID''
data2018 <- st_read("../dataE/01_CULTURES/rpg2018.shp", query = query_str)
inter2018 <- st_intersection(canton2015 [,"ID_GEOFLA"], data2018 [,"ID_PARCEL"])
data2017 <- st_read("../dataE/01_CULTURES/rpg2017.shp", query = query_str)
inter2017 <- st_intersection(canton2015 [,"ID_GEOFLA"], data2017 [,"ID_PARCEL"])
names(canton2015)
```

## Base postgis : requête


```sql

CREATE TABLE mais2018 AS (
SELECT canton.fid, canton.id_geofla,code_cultu, sum(surf_parc), canton.geom  AS surface
FROM rpg2018, canton
	WHERE ST_INTERSECTS(st_centroid(rpg2018.wkb_geometry), canton.geom)
		AND rpg2018.code_cultu LIKE 'MID'
	GROUP BY code_cultu, canton.fid
	);


CREATE TABLE mais2017 AS (
SELECT canton.fid, canton.id_geofla,code_cultu, sum(surf_parc), canton.geom  AS surface
FROM rpg2017, canton
	WHERE ST_INTERSECTS(st_centroid(rpg2017.wkb_geometry), canton.geom)
		AND rpg2017.code_cultu LIKE 'MID'
	GROUP BY code_cultu, canton.fid
	);
```

Résultat 239 et 270

On récupère la donnée directement


```{r}
library(DBI)
library(RPostgres)
# With DBI
con <- dbConnect(
  RPostgres::Postgres(),
  host = "localhost",
  dbname = "tachasa",
  port = 5432,
  user = "tachasa",
  password = "bonbon2013"
)
con
```

```{r, eval= FALSE}
mais2018 <- st_read(con, "mais2018")
mais2017 <- st_read(con, "mais2017")
# sauvegarde dans le rgp.gpkg
st_write(mais2017, "../dataS/rpg.gpkg", "mais2017", quiet = TRUE, delete_layer = TRUE)
st_write(mais2018, "../dataS/rpg.gpkg", "mais2018", quiet = TRUE, delete_layer = TRUE)
```

Selon l'intersection spatiale

```{r}
cantonZone <- canton2015 [canton2015$NOM_REG %in%  c("MIDI-PYRENEES", "AQUITAINE"),]
mais2017 <- st_read("../dataS/rpg.gpkg", "mais2017")
mais2018 <- st_read("../dataS/rpg.gpkg", "mais2018")
names(mais2017)[c(1,3)]  <- c("ID_GEOFLA", "Surface")
names(mais2018)[c(1,3)]  <- c("ID_GEOFLA", "Surface")
mais2017 <- mais2017 [, c(1,3)]
mais2018 <- mais2018 [, c(1,3)]
mais2019  <- st_read("../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, stringsAsFactors = FALSE)
mais2019 <- mais2019 [!(is.na(mais2019$MID)), c("ID_GEOFLA", "MID")]
names(mais2019) [1:2] <- c("ID_GEOFLA", "Surface")
lmais <- list(mais2017,mais2018, mais2019)
names(lmais) <- c("mais2017", "mais2018", "mais2019")
intersecterCanton <- function (datasf) {st_intersection(cantonZone [, "ID_GEOFLA"], datasf)}
linter <- lapply(lmais, intersecterCanton)
par(mfrow = c(2,3), mar = c(0,0,0,0))
choroLayer(linter [[1]], var = "Surface", legend.title.txt =  "2017")
choroLayer(linter [[2]], var = "Surface", legend.title.txt =  "2018")
choroLayer(linter [[3]], var = "Surface", legend.title.txt =  "2019")
```

Selon l'attribut

```{r}
mergerCanton <- function (datasf) {merge(cantonZone [,"ID_GEOFLA"], datasf [, c("ID_GEOFLA", "Surface"), drop = TRUE], by = "ID_GEOFLA")}
lmerger <- lapply(lmais, mergerCanton)
choroLayer(lmerger [[1]], var = "Surface", legend.title.txt =  "2017")
choroLayer(lmerger [[2]], var = "Surface", legend.title.txt =  "2018")
choroLayer(lmerger [[3]], var = "Surface", legend.title.txt =  "2019")
```

Mise en forme et export

Objectif : tableau .csv avec 2017 2018 2019 par canton

```{r}
data <- do.call(rbind,lmerger)
id <- unique(data$ID_GEOFLA)
i <- 1
for (i in 1:length(id)) {
  dataf$ID_GEOFLA [i] <- id [i]
  surface2017 <- mais2017$Surface [mais2017$ID_GEOFLA == id [i], drop = TRUE]
  dataf$annee2017 [i] <- ifelse(length(surface2017) == 0, NA,surface2017)
  surface2018 <- mais2018$Surface [mais2018$ID_GEOFLA == id [i], drop = TRUE]
  dataf$annee2018 [i] <- ifelse(length(surface2018) == 0, NA,surface2018)
  surface2019 <- mais2019$Surface [mais2019$ID_GEOFLA == id [i], drop = TRUE]
  dataf$annee2019 [i] <- ifelse(length(surface2019) == 0, NA,surface2019)
}
# export simple
write.csv2(dataf , "../dataS/comparaisonSimple.csv",row.names = FALSE, na = "0" )
# rajout des éléments identifcation canton
datafin <- merge(canton2015, dataf, by = "ID_GEOFLA")
datafinsansgeom <- datafin [,c(1:21), drop = TRUE]
write.csv2(datafinsansgeom , "../dataS/comparaison.csv",row.names = FALSE, na = "0" )
```

