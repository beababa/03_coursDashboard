---
title: "Segment"
author: "B. Maranget"
date: "08/12/2020"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Objet

Intersecter segments et communes 

# Librairies et répertoire

```{r}
library(sf)
library(cartography)
```

# Données

```{r}
commune <- st_read("../dataE/00_ADMIN/commune.shp", stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/DEPARTEMENT.shp", stringsAsFactors = F)
# liste commune canton
com2020 <- read.csv("../dataE/00_ADMIN/communes2020.csv")
can2020 <- read.csv("../dataE/00_ADMIN/canton2020.csv")
```

Communes et cantons 2020 : exploration, combien de communes fractionnées

```{r}
# 2054 cantons en 2020 (communes nouvelles et multicantons 286)
table(can2020$typect)
# 434 communes fractionnées (les plus grosses)
# Dans le code officiel géographique, les communes multicantonnales sont codées > 79
tab <- table(com2020$can)
# 3033 communes sans code canton ?
sapply(com2020$can,nchar)
# lg vides, les communes assoicées ou déléguées n'ont pas de canton ? 3033 cas
tab [1]
df <- as.data.frame(tab [-1])
# on supprime ces 3033 cas.
df$chiffre <- as.integer(substr(df$Var1,3,4) )
df1 <- df [df$chiffre > 79,]
sum(df1$Freq) 
# 282 communes fractionnées d'après mon calcul...
```

Segments, quelle version de fichier ? V11 ou segment ?

```{r}
# plusieurs couches segments
segmentV11 <-  st_read("../dataS/segment.gpkg", "v11", stringsAsFactors = F)
segment <- st_read("../dataE/01_CULTURES/segments_syst_L93.shp",  stringsAsFactors = F)
str(segment)
str(segmentV11)
# pas les mêmes variables V11 moins protocolaire
egal <- st_equals(segment, segmentV11, sparse = TRUE)
# on teste la présence d'une géométrie non identique
table (sapply(egal, length))
# les 192 géométries sont identiques !
```


# Intersection

Moins de 500 communes sont découpées dans les cantons et les segments sont basés sur des cantons...
Simplement il y a 192 segments. Observons déjà segment et cantons
Pour la géométrie des cantons, elle n'existe pas dans admin express, on la prend dans geofla 2015

```{r}
canton <- st_read("../dataE/00_ADMIN/CANTON.SHP")
# 2378 cantons en 2015
S_cantonSegment <- st_within(canton, segment, sparse = T)
table (sapply(S_cantonSegment, length))
# 2065 cantons ne sont pas dans les segments ...
```

Donc la piste canton - segment n'est pas bonne.
Le travail se fait sur commune - segment

Vérification de la méthode, commune et dpt

```{r}
S_communeDpt <-  st_within(commune, dpt, sparse = T)
M_communeDpt <-  st_within(commune, dpt, sparse = F)

S_communeDpt
M_communeDpt

str(S_communeDpt)

table(sapply(S_communeDpt,length))
# Toutes les communes sont dans un dpt
```


On détecte les communes dans un segment
On intersecte et on mesure les aires des communes hors segment

```{r}
communeSegment <- st_within(commune, segment, sparse = T)
table(sapply(communeSegment, length))
# 17 038 communes ne sont pas dans un segment, quasiment la moitié.
# autant repartir de l'intersection
communeSegmentV11 <- st_intersection(commune, segmentV11)
communeSegmentV11 <- communeSegmentV11 [, c("NOM_COM", "c_segment")]
```


```{r}
# 45 410, donc il y aurait 45 410 - 35 228 communes sur plusieurs segments
# Un exemple des problèmes topologiques
Aast <- communeSegmentV11 [communeSegmentV11$NOM_COM == "Aast",]
Aast
plot(Aast$geometry)
par(mfrow = c(1,3))
for (i in 1:3) { plot (Aast$geometry [i])}
# une piste : taille des intersections ?
taille <- sapply(Aast$geometry, st_area)
taille100 <- (taille / sum(taille)) *100
# application sur les communes représentées plus de 8 fois
tab <- table(communeSegmentV11$NOM_COM)
max(tab)
noms8 <- names(tab) [tab > 7]
par(mar = c(8,4,4,4))
tab8 <- tab [tab > 7]
barplot(sort(tab8), las = 2, main = "communes représentées plus de 8 fois")
comSeg8 <- communeSegmentV11 [communeSegmentV11$NOM_COM %in% noms8,] 
# lien aire commune et nb intersections ?
com8 <- commune [commune$NOM_COM %in% noms8, c("NOM_COM")]
com8 [order(com8$NOM_COM),]
com8$aire <- sapply(com8$geometry, st_area)
df_tab8 <- as.data.frame(tab8)
df_tab8
merge (com8, df_tab8, by.x = "NOM_COM", by.y = "Var1")
# Pour pouvoir traiter chaque ville, on éclate en liste
lcomSeq8 <- split(communeSeg8, communeSeg8$NOM_COM)
# on meusre l'aire
mesure <- function (geometrie) {sapply(lcomSeq8, st_area)}
pct <- function (vecteur) {(vecteur / sum(vecteur)) * 100}
laire <- lapply (lcomSeq8,mesure)
lairepct <- lapply(laire, pct)