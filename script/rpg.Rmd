---
title: "RPG"
author: "B. Maranget"
date: "08/01/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

# Cadre

## Objet

agréger contenu rpg de parcelles à canton
cartographier mais doux

## Librairies et répertoire

```{r}
library(sf)
library(cartography)
```

# Données

```{r}
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# Ouverture des 100 premières lignes de fichier des parcelles
dataTest <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", 
	query = 'SELECT * FROM "parcelle_graphique" LIMIT 100' )
# liste des variables culture année 2017 (ancien fichier résultat)
culture <- read.csv("../dataE/01_CULTURES/culture.csv", header = FALSE, stringsAsFactors = FALSE)
culture <- culture$V1
# 297 colonnes 280 d'origigine et rajout col avec 8 
canton2015 <- st_read("../dataE/00_ADMIN/CANTON.SHP")
```


# Récupération des données du fichier des parcelles

## Ouverture

Le fichier comporte 9 millions de parcelles, il ne s'ouvre pas en totalité sous R.

On pourrait l'ouvrir via une boucle sur chaque code culture

```{r, eval=FALSE}
i <- 1
query_str <- paste0('SELECT ID_PARCEL, geom FROM "parcelle_graphique" WHERE CODE_CULTU = "', culture [i], "\"") 
data <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", query = query_str)
inter <- st_intersection(canton2015 [,"CODE_CANT"], data [,"ID_PARCEL"])
```

On pourrait l'ouvrir sans la géométrie


```{r, eval = FALSE}
#  téléchargement du fichier sans la géomtrie
dataSansGeom <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique",
  query = 'SELECT  ID_PARCEL , CODE_CULTU , CODE_GROUP FROM "parcelle_graphique" ' )
```

On préfère mettre en place une base postgis et on fait l'agregation dedans.


```SQL
CREATE TABLE data2019 AS (
SELECT canton.fid, canton.id_geofla,code_cultu, sum(surf_parc)  AS surface
FROM parcelle_graphique, canton
	WHERE ST_INTERSECTS(st_centroid(parcelle_graphique.geom), canton.geom)
	GROUP BY code_cultu, canton.fid
	);
```


TODO attaquer la base postgis depuis R
Mais le traitement des guillemets est complexe

```{r}
library(DBI)
library(RPostgres)
# With DBI
con <- dbConnect(
  RPostgres::Postgres(),
  host = "localhost",
  dbname = "tachasa",
  port = 5432,
  user = "tachasa",
  password = "bonbon2013"
)

```


TODO explorer diply et sqlite


La table contient donc toutes les données du fichier. Pour alléger, on a enlevé 
les géométries à l'export mais l'intersection s'est fait sur les géométries
L'identifiant  (fid) correspond au rang des cantons de 1 à 
Le geofla permet de valider le fid

TODO pourquoi cette multiplicité d'identifiants ?

## Création d'un identifiant simple

```{r}
data <- read.csv("../dataS/lien.csv", sep = "\t", dec = ".", header  = FALSE)
#  106 660 lg
names(data) <- c("ID_CANTON", "CULTURE", "SURFACE")
table(data$CULTURE)
# l'id canton correspond à un numéro incrementé dans la base postgis de 1 à 2378
# ajout de lID
canton2015$ID_CANTON <- seq(1:2378)
```

TODO Pour s'assurer que l'id canton est ok on compare les deux geofla

## Calcul de la SAU pour toutes les cultures pour chaque canton

```{r}
SAU <-  aggregate(data$SURFACE, by = list (data$ID_CANTON), sum)
names(SAU) <- c("ID_CANTON", "SAU_HA")
canton2015b <- merge(canton2015, SAU, by = "ID_CANTON")
# 2281 cantons avec une SAU contre 2378 cantons au total
diff <- setdiff(canton2015$ID_CANTON,canton2015b$ID_CANTON)
cantondiff <- canton2015 [canton2015$ID_CANTON %in% diff,]
plot(dpt$geom, col = "antiquewhite1", border = "white")
plot(cantondiff$geometry, add = TRUE, col= "red", border = NA)
canton2015 <- canton2015b
```


Il y 97 cantons sans culture.

TODO analyse canton sans culture ?

TODO pb surface bio inclu dans SAU ?

## Vérification import données

Pour vérification, on va extraire de la table le CAE via R


```{r, eval= FALSE}
cae <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", 
	query = 'SELECT * FROM "parcelle_graphique" WHERE CODE_CULTU = "CAE"')
st_write(cae, "../dataS/rpg.gpkg", "cae", delete_layer = TRUE, quiet = TRUE)
head(cae)
cae.c <- st_centroid(cae)
caeCantonInter <- st_intersection(cae, canton2015)
nrow(caeCantonInter) - nrow(cae)
# 41 morceaux de parcelles sur 2634.
str(caeCantonInter)
# verif des aires
caeCantonInter$aire <- round(st_area(caeCantonInter)/10000,2)
caeCantonInter$aire <- as.numeric(caeCantonInter$aire)
caeCantonInter$verif <- caeCantonInter$SURF_PARC - caeCantonInter$aire
plot((caeCantonInter$verif))
# 91 aires différentes
caeCantonAire <-caeCantonInter [, c("aire", "ID_GEOFLA"), drop = FALSE]
caeCantonAgg <- aggregate(aire~ID_GEOFLA,caeCantonAire, sum)
# on rattache les géométries des cantons.
caeData <- merge(caeCantonAgg, canton2015, by = "ID_GEOFLA")
caeData <- st_as_sf(caeData)
choroLayer(caeData, var ="aire")
st_write(caeData, "../dataS/rpg.gpkg", "verifCAE", quiet = TRUE, delete_layer = TRUE)

dataCAE <- data [data$CULTURE == "CAE",]

st_write(dataCAE, "../dataS/rpg.gpkg", "baseCAE", quiet = TRUE, delete_layer = TRUE)
```


Il y a de légères différences dûes à l'utilisation du centroid dans la requete sql.


TODO vérification sur les quantités totales de culture




# Catégories de culture

## Problème : pas toutes les variables dans le rpg 2019

```{r}
dataCulture <- names (table(data$CULTURE))
diff <- setdiff(culture, dataCulture)
# exclusion 10 codes
setdiff(dataCulture, culture)
cultureDef <- intersect(culture,dataCulture)
# cultureDef représente les champs présents dans les deux tables (231)
# on filtre ensuite sur les cultures nécessaires uniquement
dataFiltre <- data [data$CULTURE %in% cultureDef,]
# 103 430 lg. -3 000 c'est toujours bon à prendre 
```


## Vérification code culture possible entre fichier sans geom et lien


```{r, eval = FALSE}
#  téléchargement du fichier sans la géomtrie
dataSansGeom <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique",
  query = 'SELECT  ID_PARCEL , CODE_CULTU , CODE_GROUP FROM "parcelle_graphique" ' )
cultureSansGeom <- names(table(dataSansGeom$CODE_CULTU))
setdiff(cultureSansGeom, vCulture)
```

Donc les données sont sûres....

# Mise en forme des données

Le tableau final comporte une transposition de la colonne en ligne.

## Transpostion données colonne ligne

```{r}
# création df nb de lg = nb de cantons et nb de col = nb de cultures + Canton
df <- data.frame(matrix
                    (vector(),
                    2281,232,
                    dimnames = list(c(), c("ID_CANTON",cultureDef))
                    ),
                 stringsAsFactors = F)
# parcours de dataFiltre
nb <- length(dataFiltre$ID_CANTON)
i <- 1
for (i in 1:nb) {
  surface <- dataFiltre$SURFACE [i]
  canton <- dataFiltre$ID_CANTON [i]
  culture <- dataFiltre$CULTURE [i]
  df [df$ID_CANTON == canton ,  culture] <- surface
}
# verif : compter les totaux
sum(df [,-1], na.rm = TRUE)
sum(dataFiltre$SURFACE)
```


##  Fusion avec colonnes finales

```{r}
# on fait la jointure avec les géométries des cantons
dfFusion <- merge(canton2015, df, by = "ID_CANTON")
# 2281
# pour fichier final
col <- c("Code_canto",  "NOM_CHF", "CODE_DEPT", "NOM_DEPT", "CODE_REG","NOM_REG", "CODE_CANT", "SAU_HA", cultureDef)
dfFusion <- dfFusion [, col]
st_write(dfFusion, "../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, delete_layer = TRUE)
# export des données alpha numériques uniquement
dfSansGeom <- dfFusion [, col, drop = TRUE]
write.csv2(dfSansGeom, "../dataS/dataFinale.csv", na = "" , row.names = FALSE)
# 2281 lignes
```


## Extraction des données à cartographier

MD 2017	MD 2018	MD 2019	MD / TA	MD/ surf tot	MD/surf M	MD/légumes

l'extraction s'est faite sous excel mais j'ai toujorus le pb de l'identifiant unique.


```{r}
data <- read.csv2("../dataE/01_CULTURES/extraction.csv")
data.sf <-  merge(canton2015, data, by = "CODE_CAN")
names(data)
names(canton2015)
unique(data$Code_canto)
length(unique(canton2015$Code_canto))
# 1972 code canton pour 2378 lignes dans le fichier canton
```

Impossible de faire la jointure puisqu'il y a un problème d'identifiant unique.
On repart de la totalité de la donnée.

```{r}
data <- st_read("../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, stringsAsFactors = FALSE)
code <- read.csv2("../dataE/01_CULTURES/code_culture.csv", stringsAsFactors = FALSE)
# filtrage sur MP et Aquitaine
table(data$NOM_REG)
dataSel <- data [data$NOM_REG %in% c("MIDI-PYRENEES", "AQUITAINE"),]
# 323 cantons concernés
# calcul des agregats
# TA
codeTA <- code$Code.Culture[code$TA == "Oui"]
coderpg <- names(data) [9:239]
tail(coderpg)
# verif BTH jusqu'à TRU
codeTA2 <- intersect(codeTA, coderpg)
# mais
codeMais <- code$Code.Culture[code$Maïs == "Oui"]
codeMais2 <- intersect(codeMais, coderpg)
# Légumes
codeLegume <- code$Code.Culture[code$Légumes == "Oui"]
codeLegume2 <- intersect(codeLegume, coderpg)
codeLegume2 <- c("MID", codeLegume2)
# différences entre codes totaux et codes utilisés
dataSel$TA <- rowSums(dataSel [, codeTA2, drop = TRUE], na.rm = TRUE)
dataSel$Mais <- rowSums(dataSel [, codeMais2, drop = TRUE], na.rm = TRUE)
dataSel$Legume <- rowSums(dataSel [, codeLegume2, drop = TRUE], na.rm = TRUE)
# rapports
data$ratio_MID_TA <- (data$MID/data$TA)*100
data$ratio_MID_Mais <- (data$MID/data$Mais)*100
data$ratio_MID_Legume <- (data$MID/data$Legume)*100
data$ratio_MID_SAU <- (data$MID/data$SAU_HA)
# vérif avec totaux
idcol <- grep( "ratio",names(dataSel))
colSums(dataSel [,idcol, drop = TRUE], na.rm = TRUE)
# export pour carto
st_write(dataSel  [,c("MID",names(dataSel)[idcol])], "../dataS/rpg.gpkg", "dataCarte", quiet = TRUE, delete_layer = TRUE)
dataSel
```


# Cartographie

```{r}
data <- st_read("../dataS/rpg.gpkg", "dataCarte", quiet = TRUE, stringsAsFactors = FALSE)
noms <- names(data)
bksAire <- c(0,50,150,300,500,1000, 6000)
bksMais <- c(0,10,20,30,40)
bksLegume <- c(0,20,40,60,80,100)
data$ratio_MID_SAU <- data$ratio_MID_SAU * 100
bksSAU <- c(0,5,10,15,20,25)
lbks <- list(bksAire,bksTA, bksMais, bksLegume,bksSAU)
palettes <- c("taupe.pal","blue.pal", "purple.pal", "green.pal", "red.pal")
nbcl <- c(6,5,4,5,5)
titreLegende <- c("aire (ha)", rep("ratio (%)",4))
titreCarte <- c("Surface maïs doux", "Rapport maïs et terre arable (TA)", "Rapport maïs doux et maïs",
                "Rapport maïs et légume", "Rapport maïs et SAU")
```

```{r}
i <- 1
for (i in 1:5) {
  sizes <- getFigDim(x = data, width = 3000, mar = c(0,0,1.2,0), res = 500)
  png(paste0("../img/rpg",i , ".png"), height = sizes [2], width = sizes [1], res = 500)
  par(mar = c(0,0,1.2,0))
  my.pal <- carto.pal(palettes [i], nbcl [i])
  ghostLayer(data, bg = "lightblue1")
  plot(canton2015$geom, col = "antiquewhite2", border = NA,add = TRUE)
  choroLayer(data, var = noms [i], 
             legend.title.txt = titreLegende [i], legend.pos = "topright",
             breaks = lbks [[i]], col = my.pal, nclass = nbcl [i] , border = "antiquewhite3", add = TRUE)
  layoutLayer(title = titreCarte [i], author = "Arvalis 2020", sources = "RPG 2019", horiz = FALSE,
              posscale = "bottomleft", theme = palettes [i])
  dev.off()
}


```


# Chiffres 2017 et 2018 pour le maïs doux

## Essais St_read non concluants sur du shpae...

```{r}
# verif en tête
dataTest <- st_read("../dataE/01_CULTURES/rpg2018/PARCELLES_GRAPHIQUES.shp",
	query = "SELECT ID_PARCEL, CODE_CULTU FROM \"PARCELLES_GRAPHIQUES\" 
                    WHERE CODE_CULTU LIKE ORH" )
dataTest
query_str <- 'SELECT ID_PARCEL, CODE_CULTU, _ogr_geometry_ FROM "parcelle_graphique" 
                    WHERE CODE_CULTU = 'MID''
data2018 <- st_read("../dataE/01_CULTURES/rpg2018.shp", query = query_str)
inter2018 <- st_intersection(canton2015 [,"ID_GEOFLA"], data2018 [,"ID_PARCEL"])
data2017 <- st_read("../dataE/01_CULTURES/rpg2017.shp", query = query_str)
inter2017 <- st_intersection(canton2015 [,"ID_GEOFLA"], data2017 [,"ID_PARCEL"])
names(canton2015)
```

## Base postgis : requête


```{sql}
CREATE TABLE lien2018 AS (
SELECT canton.fid, code_cultu, sum(surf_parc), canton.geom  AS surface
FROM rpg2018, canton
	WHERE ST_INTERSECTS(st_centroid(rpg2018.wkb_geometry), canton.geom)
		AND rpg2018.code_cultu LIKE 'MID'
	GROUP BY code_cultu, canton.fid
	);
```


Remarque, on a ajouté les géométries et le filtre MID

On a besoin également de l'équivalence canton.fid et geofla

```{r}
cantonId <- read.csv2("../dataE/00_ADMIN/canton.csv", sep = "\t", header = FALSE)
head(cantonId [, 1:17])
cantonId <- cantonId [,1:2]
names(cantonId) <- c("FID","ID_GEOFLA")
head(cantonId)
canton2015 <- merge(canton2015, cantonId, by = "ID_GEOFLA")
```

Selon l'intersection spatiale

```{r}
cantonZone <- canton2015 [canton2015$NOM_REG %in%  c("MIDI-PYRENEES", "AQUITAINE"),]
mais2017 <- st_read("../dataS/rpg.gpkg", "mais2017")
mais2018 <- st_read("../dataS/rpg.gpkg", "mais2018")
inter2017 <- st_intersection(cantonZone, mais2017)
inter2018 <- st_intersection(cantonZone, mais2018)
names(inter2017)
par(mfrow = c(2,2), mar = c(0,0,0,0))
choroLayer(inter2017, var = "sum")
choroLayer(inter2018, var = "sum")
```

Selon l'attribut

```{r}
names(mais2017)[c(1,3)]  <- c("ID_GEOFLA", "Surface")
names(mais2018)[c(1,3)]  <- c("ID_GEOFLA", "Surface")
attr2017 <- merge (canton2015, mais2017 [, c(1,3), drop = TRUE], by = "ID_GEOFLA")
attr2018 <- merge(canton2015, mais2018 [, c(1,3), drop = TRUE], by = "ID_GEOFLA")
choroLayer(attr2017 [ attr2017$NOM_REG %in%  c("MIDI-PYRENEES", "AQUITAINE"),], var = "Surface")
choroLayer(attr2018 [attr2018$NOM_REG %in%  c("MIDI-PYRENEES", "AQUITAINE"),], var = "Surface")
```

Mise en forme et export

```{r}

write.csv2(attr2017 [, c(1:10), drop = TRUE], "../dataS/mais2017.csv", na = "")
write.csv2(attr2018 [, c(1:10), drop = TRUE], "../dataS/mais2018.csv", na = "")
```

