---
title: "RPG"
author: "B. Maranget"
date: "08/01/2021"
output: 
  html_document: 
    number_sections: yes
    toc: yes
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = TRUE)
knitr::opts_chunk$set(warning = FALSE)
```

# Cadre

## Objet

agréger contenu rpg de parcelles à canton


## Librairies et répertoire

```{r}
library(sf)
library(cartography)
```

# Données

```{r}
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
# Ouverture des 100 premières lignes de fichier des parcelles
dataTest <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", 
	query = 'SELECT * FROM "parcelle_graphique" LIMIT 100' )
# liste des variables culture année 2017 (ancien fichier résultat)
culture <- read.csv("../dataE/01_CULTURES/culture.csv", header = FALSE, stringsAsFactors = FALSE)
culture <- culture$V1
# 297 colonnes 280 d'origigine et rajout col avec 8 
canton2015 <- st_read("../dataE/00_ADMIN/CANTON.SHP")
```


# Récupération des données du fichier des parcelles

## Ouverture

Le fichier comporte 9 millions de parcelles, il ne s'ouvre pas en totalité sous R.

On pourrait l'ouvrir via une boucle sur chaque code culture

```{r, eval=FALSE}
i <- 1
query_str <- paste0('SELECT ID_PARCEL, geom FROM "parcelle_graphique" WHERE CODE_CULTU = "', culture [i], "\"") 
data <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", query = query_str)
inter <- st_intersection(canton2015 [,"CODE_CANT"], data [,"ID_PARCEL"])
```

On pourrait l'ouvrir sans la géométrie


```{r, eval = FALSE}
#  téléchargement du fichier sans la géomtrie
dataSansGeom <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique",
  query = 'SELECT  ID_PARCEL , CODE_CULTU , CODE_GROUP FROM "parcelle_graphique" ' )
```

On préfère mettre en place une base postgis et on fait l'agregation dedans.


```SQL
CREATE TABLE lien AS (
SELECT canton.fid, code_cultu, sum(surf_parc)  AS surface
FROM parcelle_graphique, canton
	WHERE ST_INTERSECTS(st_centroid(parcelle_graphique.geom), canton.geom)
	GROUP BY code_cultu, canton.fid
	);
```



TODO explorer diply et sqllite


La table contient donc toutes les données du fichier. Pour alléger, on a enlevé 
les géométries à l'export mais l'intersection s'est fait sur les géométries
L'identifiant  (fid) correspond aux derniers chiffres de l'identifiant géofla.

TODO pourquoi cette multiplicité d'identifiants ?

## Création d'un identifiant simple

```{r}
data <- read.csv("../dataS/lien.csv", sep = "\t", dec = ".", header  = FALSE)
#  106 660 lg
names(data) <- c("ID_CANTON", "CULTURE", "SURFACE")
table(data$CULTURE)
# simplification de l'identifiant geofla
canton2015$ID_CANTON <- as.integer(substring(canton2015$ID_GEOFLA, 21,29))
# verif identiant unique 2378 cantons.
length(unique(canton2015$ID_CANTON))
```

## Calcul de la SAU pour toutes les cultures pour chaque canton

```{r}
SAU <-  aggregate(data$SURFACE, by = list (data$ID_CANTON), sum)
names(SAU) <- c("ID_CANTON", "SAU_HA")
canton2015b <- merge(canton2015, SAU, by = "ID_CANTON")
# 2281 cantons avec une SAU contre 2378 cantons au total
diff <- setdiff(canton2015$ID_CANTON,canton2015b$ID_CANTON)
cantondiff <- canton2015 [canton2015$ID_CANTON %in% diff,]
plot(dpt$geom, col = "antiquewhite1", border = "white")
plot(cantondiff$geometry, add = TRUE, col= "red", border = NA)
canton2015 <- canton2015b
```


Il y 97 cantons sans culture.

TODO analyse canton sans culture ?

TODO pb surface bio inclu dans SAU ?

## Vérification import données

Pour vérification, on va extraire de la table le CAE via R


```{r, eval= FALSE}
cae <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique", 
	query = 'SELECT * FROM "parcelle_graphique" WHERE CODE_CULTU = "CAE"')
st_write(cae, "../dataS/rpg.gpkg", "cae", delete_layer = TRUE, quiet = TRUE)
head(cae)
cae.c <- st_centroid(cae)
caeCantonInter <- st_intersection(cae, canton2015)
nrow(caeCantonInter) - nrow(cae)
# 41 morceaux de parcelles sur 2634.
str(caeCantonInter)
# verif des aires
caeCantonInter$aire <- round(st_area(caeCantonInter)/10000,2)
caeCantonInter$aire <- as.numeric(caeCantonInter$aire)
caeCantonInter$verif <- caeCantonInter$SURF_PARC - caeCantonInter$aire
plot((caeCantonInter$verif))
# 91 aires différentes
caeCantonAire <-caeCantonInter [, c("aire", "ID_GEOFLA"), drop = FALSE]
caeCantonAgg <- aggregate(aire~ID_GEOFLA,caeCantonAire, sum)
# on rattache les géométries des cantons.
caeData <- merge(caeCantonAgg, canton2015, by = "ID_GEOFLA")
caeData <- st_as_sf(caeData)
choroLayer(caeData, var ="aire")
st_write(caeData, "../dataS/rpg.gpkg", "verifCAE", quiet = TRUE, delete_layer = TRUE)

dataCAE <- data [data$CULTURE == "CAE",]

st_write(dataCAE, "../dataS/rpg.gpkg", "baseCAE", quiet = TRUE, delete_layer = TRUE)
```


Il y a de légères différences dûes à l'utilisation du centroid dans la requete sql.


TODO vérification sur les quantités totales de culture




# Catégories de culture

## Problème : pas toutes les variables dans le rpg 2019

```{r}
dataCulture <- names (table(data$CULTURE))
diff <- setdiff(culture, dataCulture)
# exclusion 10 codes
setdiff(dataCulture, culture)
cultureDef <- intersect(culture,dataCulture)
# cultureDef représente les champs présents dans les deux tables (231)
# on filtre ensuite sur les cultures nécessaires uniquement
dataFiltre <- data [data$CULTURE %in% cultureDef,]
# 103 430 lg. -3 000 c'est toujours bon à prendre 
```


## Vérification code culture possible entre fichier sans geom et lien


```{r, eval = FALSE}
#  téléchargement du fichier sans la géomtrie
dataSansGeom <- st_read("../dataE/01_CULTURES/PARCELLES_GRAPHIQUES.gpkg", "parcelle_graphique",
  query = 'SELECT  ID_PARCEL , CODE_CULTU , CODE_GROUP FROM "parcelle_graphique" ' )
cultureSansGeom <- names(table(dataSansGeom$CODE_CULTU))
setdiff(cultureSansGeom, vCulture)
```

Donc les données sont sûres....

# Mise en forme des données

Le tableau final comporte une transposition de la colonne en ligne.

## Transpostion données colonne ligne

```{r}
# création df nb de lg = nb de cantons et nb de col = nb de cultures + Canton
df <- data.frame(matrix
                    (vector(),
                    2281,232,
                    dimnames = list(c(), c("ID_CANTON",cultureDef))
                    ),
                 stringsAsFactors = F)
# parcours de dataFiltre
df$ID_CANTON <- unique(data$ID_CANTON)
nb <- length(dataFiltre$ID_CANTON)
i <- 1
for (i in 1:nb) {
  surface <- dataFiltre$SURFACE [i]
  canton <- dataFiltre$ID_CANTON [i]
  culture <- dataFiltre$CULTURE [i]
  df [df$ID_CANTON == canton ,  culture] <- surface
}
# verif : compter les totaux
sum(df [,-1], na.rm = TRUE)
sum(dataFiltre$SURFACE)
```


##  Fusion avec colonnes finales

```{r}
# on fait la jointure avec les géométries des cantons
dfFusion <- merge(canton2015, df, by = "ID_CANTON")
# 2281
# pour fichier final
col <- c("Code_canto",  "NOM_CHF", "CODE_DEPT", "NOM_DEPT", "CODE_REG","NOM_REG", "CODE_CANT", "SAU_HA", cultureDef)
dfFusion <- dfFusion [, col]
st_write(dfFusion, "../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, delete_layer = TRUE)
# export des données alpha numériques uniquement
dfSansGeom <- dfFusion [, col, drop = TRUE]
write.csv2(dfSansGeom, "../dataS/dataFinale.csv", na = "" , row.names = FALSE)
# 2281 lignes
```


## Extraction des données à cartographier

MD 2017	MD 2018	MD 2019	MD / TA	MD/ surf tot	MD/surf M	MD/légumes

l'extraction s'est faite sous excel mais j'ai toujorus le pb de l'identifiant unique.


```{r}
data <- read.csv2("../dataE/01_CULTURES/extraction.csv")
data.sf <-  merge(canton2015, data, by = "CODE_CAN")
names(data)
names(canton2015)
unique(data$Code_canto)
length(unique(canton2015$Code_canto))
# 1972 code canton pour 2378 lignes dans le fichier canton
```

Impossible de faire la jointure puisqu'il y a un problème d'identifiant unique.
On repart de la totalité de la donnée.

```{r}
data <- st_read("../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, stringsAsFactors = FALSE)

code <- read.csv2("../dataE/01_CULTURES/code_culture.csv", stringsAsFactors = FALSE)
# filtrage sur MP et Aquitaine
table(data$NOM_REG)
data <- data [data$NOM_REG %in% c("MIDI-PYRENEES", "AQUITAINE"),]
# 323 cantons concernés
# calcul des agregats
# TA
codeTA <- code$Code.Culture[code$TA == "Oui"]
coderpg <- names(data) [9:239]
tail(coderpg)
# verif BTH jusqu'à TRU
codeTA2 <- intersect(codeTA, coderpg)
# mais
codeMais <- code$Code.Culture[code$Maïs == "Oui"]
codeMais2 <- intersect(codeMais, coderpg)
# Légumes
codeLegume <- code$Code.Culture[code$Légumes == "Oui"]
codeLegume2 <- intersect(codeLegume, coderpg)
# différences entre codes totaux et codes utilisés
data$TA <- rowSums(data [, codeTA2, drop = TRUE], na.rm = TRUE)
data$Mais <- rowSums(data [, codeMais2, drop = TRUE], na.rm = TRUE)
data$Legume <- rowSums(data [, codeLegume2, drop = TRUE], na.rm = TRUE)
# rapports
data$ratio_MID_TA <- (data$MID/data$TA)*100
data$ratio_MID_Mais <- (data$MID/data$Mais)*100
data$ratio_MID_Legume <- (data$MID/data$Legume)*100
data$ratio_MID_SAU <- (data$MID/data$SAU_HA)
# vérif avec totaux
idcol <- grep( "ratio",names(data))
colSums(data [,idcol, drop = TRUE], na.rm = TRUE)
# export pour carto
st_write(data, "../dataS/rpg.gpkg", "dataFinale", quiet = TRUE, delete_layer = TRUE)
```


# Cartographie

```{r}
bksMais <- c(10,20,30,40)
bksLegume <- c(10,20,30)
bksSAU <- c(5,10,15,20,25)
bksTA <- c(5,10,15,20,25)
```





