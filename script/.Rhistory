numCanton <- data$ID_CANTON [i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
i <- 2
numCanton <- data$ID_CANTON [i]
numCanton
# 242 * 2378 = 575 M cellules à faire...
df
vnumCanton <- unique(data$ID_CANTON)
i <- 1
for (numCanton in 1:2) {
numCanton <- vnumCanton[i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
for (j in 1:length(vCulture)) {
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
df
i <- 1
for (numCanton in 1:3) {
numCanton <- vnumCanton[i]
df [i, "ID_CANTON" ]<- numCanton
j <- 1
for (j in 1:length(vCulture)) {
print(surface <- data$SURFACE [data$ID_CANTON == numCanton & data$CULTURE == vCulture [j]])
surface <- ifelse(length(surface) == 0, 0, surface)
df [data$ID_CANTON [i],vCulture[j]] <- surface
}
}
df
install.packages("sf")
install.packages("cartography")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
install.packages("knitr")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
library(cartography)
install.packages("cartography")
install.packages("rgdal")
install.packages("sf")
install.packages("units")
install.packages("units")
install.packages("sf")
install.packages("rgdal")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(cartography)
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# on éclate les données par zone puis par an
lzone <- split(inter, inter$groupe)
# enregistrement en fichiers pour qgis
enregistrer <- function(df,num) {
zone <- substring(deparse(substitute(df)),1,6)
print(zone)
annee <- df [1, c("an"), drop = TRUE]
st_write(df, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_", annee), quiet = TRUE, delete_layer = TRUE)
}
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
# Xunion <- st_union(X)
# Yunion <- st_union(Y)
st_write(X, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
zone1 <- lzone [[1]]
enregistrerAnneeUnique(zone1,1)
diff <- st_read("../dataS/chrysomelediff.gpkg", layer = "2015", quiet = TRUE)
total <- sum(st_area(diff))
zone2 <- lzone [[2]]
zone3 <- lzone [[3]]
zone4 <- lzone [[4]]
enregistrerAnneeUnique(zone1,1)
enregistrerAnneeUnique(zone1,2)
enregistrerAnneeUnique(zone1,3)
enregistrerAnneeUnique(zone1,4)
enregistrerAnneeUnique(zone2,1)
enregistrerAnneeUnique(zone2,2)
enregistrerAnneeUnique(zone2,3)
enregistrerAnneeUnique(zone2,4)
layers <- ogrListLayers("../dataS/chrysomelexport.gpkg")
library("rgdal")
install.packages("rgdal")
library("rgdal")
layers <- ogrListLayers("../dataS/chrysomelexport.gpkg")
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
# Xunion <- st_union(X)
# Yunion <- st_union(Y)
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
zone1 <- lzone [[1]]
zone2 <- lzone [[2]]
zone3 <- lzone [[3]]
zone4 <- lzone [[4]]
enregistrerAnneeUnique(zone1,1)
enregistrerAnneeUnique(zone1,2)
enregistrerAnneeUnique(zone1,3)
enregistrerAnneeUnique(zone1,4)
enregistrerAnneeUnique(zone2,1)
enregistrerAnneeUnique(zone2,2)
enregistrerAnneeUnique(zone2,3)
enregistrerAnneeUnique(zone2,4)
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
# Xunion <- st_union(X)
# Yunion <- st_union(Y)
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
zone1 <- lzone [[1]]
zone2 <- lzone [[2]]
zone3 <- lzone [[3]]
zone4 <- lzone [[4]]
enregistrerAnneeUnique(zone1,1)
enregistrerAnneeUnique(zone1,2)
enregistrerAnneeUnique(zone1,3)
enregistrerAnneeUnique(zone1,4)
enregistrerAnneeUnique(zone2,1)
enregistrerAnneeUnique(zone2,2)
enregistrerAnneeUnique(zone2,3)
enregistrerAnneeUnique(zone2,4)
enregistrerAnneeUnique(zone4,1)
enregistrerAnneeUnique(zone4,2)
enregistrerAnneeUnique(zone4,3)
enregistrerAnneeUnique(zone4,4)
enregistrerAnneeUnique(zone3,1)
enregistrerAnneeUnique(zone3,2)
enregistrerAnneeUnique(zone3,3)
enregistrerAnneeUnique(zone3,4)
diff2018 <- st_read("../dataS/chrysomelediff.gpkg", layer = "2018", quiet = TRUE)
total2015 <- sum(st_area(diff2018))
diff2018 <- st_read("../dataS/chrysomelediff.gpkg", layer = "2018", quiet = TRUE)
total2018 <- sum(st_area(diff2018))
total <- c(total2015, total2018)
total2015 <- sum(st_area(diff2015))
diff2015 <- st_read("../dataS/chrysomelediff.gpkg", layer = "2015", quiet = TRUE)
total2015 <- sum(st_area(diff2015))
diff2018 <- st_read("../dataS/chrysomelediff.gpkg", layer = "2018", quiet = TRUE)
total2018 <- sum(st_area(diff2018))
total <- c(total2015, total2018)
total
names(total)
total <- c("t2015" = total2015, "t2018" = total2018)
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
# Chunk 2
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(cartography)
# Chunk 3
# communes sans la corse
commune <- st_read("../dataE/00_ADMIN/ign.gpkg", "commune", quiet = TRUE,stringsAsFactors = F)
dpt <- st_read("../dataE/00_ADMIN/ign.gpkg", "dpt", quiet = TRUE, stringsAsFactors = F)
canton2015 <- st_read("../dataE/00_ADMIN/canton2015/CANTON.SHP")
# rpg dezipage
chemin <-"../dataE/01_CULTURES/rpg/"
noms <- list.files(chemin)
for (i in 1:length(noms)){
unzip(zipfile =  paste0(chemin,noms[i]), exdir = chemin)
}
# assemblage
noms <- list.files(chemin,pattern = ".shp")
data <- NULL
i <- 1
for (i in 1:length(noms)){
tmp <- st_read(paste0(chemin, noms [i]))
tmp <- tmp [tmp$Code_cultu %in% c("MID", "MIE", "MIS"), ]
tmp$an <- substring(noms [i],9,12)
data <- rbind(data,tmp)
}
# exploration
rpg <- data  [, c("Code_cultu", "an")]
par(mar = c(4,4,4,4))
tab <- table(rpg$Code_cultu, rpg$an)
tab
barplot(tab, beside = T, col = heat.colors(3), border = NA)
# liste
lrpg <- split(rpg, rpg$an)
names(lrpg) <- c("rpg2015", "rpg2016", "rpg2017", "rpg2018")
# Enregistrement en format .gpkg
st_write(rpg, "../dataS/chrysomele.gpkg", "rpg", row.names = FALSE,quiet = TRUE, delete_layer = TRUE)
# Chunk 4
test2015 <- rpg2015 [rpg2015$geometry [1],]
bb <- st_as_sfc(st_bbox(test2015))
test2015 <- st_intersection( st_make_valid(rpg2015), bb)
test2016 <- st_intersection( st_make_valid(rpg2015), bb)
test2017 <- st_intersection( st_make_valid(rpg2017), bb)
test2018 <- st_intersection( st_make_valid(rpg2018), bb)
ltest <- list(test2015, test2016, test2017, test2018)
names(ltest) <- c("test2015", "test2016", "test2017", "test2018")
# observation différence
plot(test2015$geometry)
plot(test2016$geometry, col = "red", add = TRUE)
plot(test2017$geometry, col = "blue", add = TRUE)
plot(test2018$geometry, col = "green", add = TRUE)
test_2015_2016 <- st_equals(test2015, test2016, sparse = T)
table(sapply(test_2015_2016, length))
# sur 21 geometries, 9 sont différentes...
rpg2015_2016  <- st_equals(st_make_valid(rpg2015), st_make_valid(rpg2016), sparse = T)
table(sapply(rpg2015_2016, length))
# meme proportion
# Chunk 5
alsace <- read.csv2("../dataE/00_ADMIN/alsace.csv")
names(alsace) <- c("zone", "PR", "nom", "CODE_CANTO")
canton2012 <- st_read("../dataE/00_ADMIN/canton2012/CANTON.SHP", quiet = TRUE, stringsAsFactors = TRUE)
str(alsace)
str(canton2012)
cantonS <- canton2012 [ canton2012$NOM_REG == "ALSACE",]
alsace.sf <- merge (cantonS, alsace, by = "CODE_CANTO")
alsace.sf <- alsace.sf [, c("CODE_CANTO", "ID_GEOFLA","zone", "PR", "nom" ),]
st_write(alsace.sf, "../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, delete_layer = TRUE)
plot(alsace.sf$geometry)
# Chunk 6
ldata <- list(rpg2015, rpg2016, rpg2017, rpg2018)
calcul <- function(data) {
(sum(st_area(data)) / nrow(data))/10000
}
sapply(ldata,calcul)
# Chunk 7
# Chunk 8
data <- c("test2015", "test2016", "test2017", "test2018")
ldata <- list(test2015,test2016,test2017,test2018)
names(ldata) <- c("année1", "année2", "année3", "année4")
lcentr <- lapply(ldata, st_centroid)
str(lcentr)
aspect <- c(0,10,20,3)
col <- c("red", "green", "blue", "black")
plot(test2015$geometry)
for (i in 1:4) {
plot(lcentr [[i]][10], pch = aspect [i], col = col [i], add = TRUE)
}
# Chunk 9
grid <- st_make_grid(bb, cellsize = 100)
plot(test2015$geometry)
plot(grid, add = TRUE)
# Chunk 10
inter <- function(data) { st_intersection(data, grid)}
linter <- lapply(ldata, inter)
sapply(linter, nrow)
# Chunk 11
pct <- function(aire) { (aire / 10000) * 100}
laire <- lapply(linter, st_area)
lcoeff <- lapply(laire, pct)
# Chunk 12
# filtrage des carreaux
sel <- function (data) {data [data [,4, drop = TRUE] == "BTH",]}
ldataBTH <- lapply (linter, sel)
couleur <- c("red","blue", "green", "black")
par(mar = c(0,0,1.2,0), mfrow = c(2,2))
i <- 1
for (i in 1:4) {
plot(ldataBTH [[i]][10], border = couleur [i])
layoutLayer(title = names(ldataBTH [i]))
}
# Chunk 13
res1 <- st_intersection(ldataBTH$année1, ldataBTH$année2)
res2 <- st_intersection(res1, ldataBTH$année3)
res3 <- st_intersection (res2, ldataBTH$année4)
aireMais <- round(sum(st_area(res3))/10000,2)
plot(res3$geometry)
plot(test2015$geometry)
plot(res3, add = TRUE)
layoutLayer(paste0("aire blé cultivé uniquement en 2015 : ",aireMais, " ha"))
# on calcule l'aire de res3 uniquement
# Chunk 14
ltestBTH <- lapply (ldata, sel)
# assembler les polygones des différentes couches
Y <- st_union(st_union(ltestBTH$test2016), st_union(ltestBTH$test2017), st_union(ltestBTH$test2018))
X <- st_union(ltestBTH$test2015)
# graphique
par(mfrow = c(1,2))
plot(X)
plot(Y, col = "blue")
# parcelle où mais cultivé en 2015
res1 <- st_difference(X, Y)
plot(res1)
(round(st_area(res1),0))
# Chunk 15
lunion <- lapply(ltestBTH, st_union)
# Chunk 16
anneeUnique <- function(lunion, num) {
X <- lunion [[num]]
lreste <- lunion
lreste [[num]] <- NULL
Y <- st_union(lreste [[1]], lreste [[2]], lreste [[3]])
res <- st_difference(X,Y )
# graphique
# par(mfrow = c(1, 3))
# plot(X, main = num)
# plot(Y, col = "blue", main = "autres")
# plot(res, main = "difference")
round(st_area(res),0)
}
# Chunk 17
lnum <- c(1,2,3,4)
sapply(lnum, anneeUnique)
# Chunk 18
deuxAnsOLD <- function (num1,num2, lunion) {
X <- st_union(lunion [[num1]], lunion [[num2]])
lreste <-lunion [c(-num1,-num2)]
Y <- st_union (lreste [[1]], lreste [[2]])
# Toutes les géométries de X qui ne sont pas dans Y
res <- st_difference(X,Y )
# couteux
# graphique
# par(mfrow = c(2, 2))
# plot(X, main = paste(num1, num2))
# plot(Y, col = "blue", main = "autres")
# plot(res, main = "difference")
# Elimination des petits petits polygones (500 m2)
# TO DO valider cette limite
#res2 <- st_cast(res, "MULTILINESTRING")
res3 <- st_cast(res, "MULTIPOLYGON")
res4 <- sapply(st_as_sf(res3), st_area)
indice <- which(round(res4,0) > 500)
#plot(res2 [indice], main = "retenu")
res5 <- round(st_area (res3 [indice]),0)
return(res5)
}
deuxAns <- function (num1,num2, lunion) {
X <- st_union(lunion [[num1]], lunion [[num2]])
lreste <-lunion [c(-num1,-num2)]
Y <- st_union (lreste [[1]], lreste [[2]])
# Toutes les géométries de X qui ne sont pas dans Y
res <-
st_cast(st_difference(X,Y ), "MULTIPOLYGON")
# couteux
# graphique
# par(mfrow = c(2, 2))
# plot(X, main = paste(num1, num2))
# plot(Y, col = "blue", main = "autres")
# plot(res, main = "difference")
# Elimination des petits petits polygones (500 m2)
# TO DO valider cette limite
#res2 <- st_cast(res, "MULTILINESTRING")
res2 <- sapply(st_as_sf(res), st_area)
indice <- which(round(res2,0) > 500)
#plot(res2 [indice], main = "retenu")
res3 <- round(res2 [indice],0)
return(res3)
}
# Chunk 19
alsace <- st_read("../dataS/chrysomele.gpkg", "cantonAlsace", quiet = TRUE, stringsAsFactors = FALSE)
rpg <- st_read("../dataS/chrysomele.gpkg", "rpg", quiet = TRUE, stringsAsFactors = FALSE)
# agrégation par zones
aggAlsace <- aggregate(alsace [,c("zone"), drop = FALSE], by = list (alsace$zone), length)
names(aggAlsace)[1:2] <- c("groupe", "nb")
plot(aggAlsace$geometry, col = "antiquewhite1")
plot(lrpg[[1]], add = TRUE)
labelLayer(aggAlsace, txt = "groupe", halo = 2 )
#lrpg <- lapply(lrpg, st_union)
# intersection très couteuse.
intersecter <- function(data) {
inter <- st_intersection(data, aggAlsace)
}
lrpg <- split(rpg, rpg$an)
lrpg <- lapply(lrpg, st_make_valid)
linter <- lapply(lrpg, intersecter)
inter <- do.call(rbind,linter)
# elimination des geometries pouvant poser pb
table(st_geometry_type(inter))
# 407 sur 275 géometries....
inter <- inter [st_geometry_type(inter) != "GEOMETRYCOLLECTION",]
data <- linter [[1]]
agg <- aggregate(data, by = list(data$groupe), length)
# sauvegarde pour éviter de refaire les manip trop coûteuse
st_write(agg, "../dataS/chrysomele.gpkg", "agg")
st_write(inter, "../dataS/chrysomele.gpkg", "inter", quiet = TRUE, delete_layer = TRUE)
# Chunk 20
agg <- st_read("../dataS/chrysomele.gpkg", "agg", quiet = TRUE, stringsAsFactors = FALSE)
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# 276 000 obs
# Chunk 21
# on éclate les données par zone puis par an
lzone <- split(inter, inter$groupe)
eclaterZoneAn <- function (num) {
df <- lzone[[num]]
ldf <- split (df, df$an)
# lcomb <- lapply(ldf, st_combine)
#lunion <- lapply(lcomb, st_union)
}
lzone1 <- eclaterZoneAn (1)
lzone2 <- eclaterZoneAn (2)
lzone3 <- eclaterZoneAn (3)
lzone4 <- eclaterZoneAn (4)
# enregistrement en fichiers pour qgis
enregistrer <- function(df,num) {
#  on récupère le nom de la zone
zone <- substring(deparse(substitute(df)),1,6)
print(zone)
annee <- df [1, c("an"), drop = TRUE]
st_write(df, dsn = "../dataS/chrysomelexport.gpkg", layer = paste0(zone,"_", annee), quiet = TRUE, delete_layer = TRUE)
}
for (i in 1:4) {
enregistrer(lzone1[[i]])
}
for (i in 1:4) {
enregistrer(lzone2[[i]])
}
for (i in 1:4) {
enregistrer(lzone3[[i]])
}
for (i in 1:4) {
enregistrer(lzone4[[i]])
}
res <- anneeUnique(lzone4,1)
# Chunk 22
enregistrerAnneeUnique <- function(df, num) {
zone <- deparse(substitute(df))
print(zone)
nomAn <- c("2015","2016","2017", "2018")
X <- df [df$an == nomAn [num], ]
Y <- df [df$an != nomAn [num],]
# L'union peut se faire sous R quand même non ?
# Xunion <- st_union(X)
# Yunion <- st_union(Y)
# obligation d'enregistrer dans des gpkg sinon qgis ne les voit pas
nomgpkg <- paste0("../dataS/chrysomelexport",zone,".gpkg")
st_write(X, dsn = nomgpkg, layer = paste0(zone,"_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
st_write(Y, dsn = nomgpkg, layer = paste0(zone,"_autres_", nomAn[num]), quiet = TRUE, delete_layer = TRUE)
}
zone1 <- lzone [[1]]
zone2 <- lzone [[2]]
zone3 <- lzone [[3]]
zone4 <- lzone [[4]]
enregistrerAnneeUnique(zone1,1)
enregistrerAnneeUnique(zone1,2)
enregistrerAnneeUnique(zone1,3)
enregistrerAnneeUnique(zone1,4)
enregistrerAnneeUnique(zone2,1)
enregistrerAnneeUnique(zone2,2)
enregistrerAnneeUnique(zone2,3)
enregistrerAnneeUnique(zone2,4)
enregistrerAnneeUnique(zone4,1)
enregistrerAnneeUnique(zone4,2)
enregistrerAnneeUnique(zone4,3)
enregistrerAnneeUnique(zone4,4)
enregistrerAnneeUnique(zone3,1)
enregistrerAnneeUnique(zone3,2)
enregistrerAnneeUnique(zone3,3)
enregistrerAnneeUnique(zone3,4)
# Chunk 23
diff2015 <- st_read("../dataS/chrysomelediff.gpkg", layer = "2015", quiet = TRUE)
total2015 <- sum(st_area(diff2015))
diff2018 <- st_read("../dataS/chrysomelediff.gpkg", layer = "2018", quiet = TRUE)
total2018 <- sum(st_area(diff2018))
total2015
total2018
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
library(sf)
# Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1
library(cartography)
inter <- st_read("../dataS/chrysomele.gpkg", "inter", quiet = TRUE, stringsAsFactors = FALSE)
# 274 083 obs, tous en multipolygone
# verif
summary(inter$aire)
# inutile de faire st_make_valid, lwgeom n'existe pas
summary(zone1)
zone1 <- lzone [[1]]
# inutile de faire st_make_valid, lwgeom n'existe pas
summary(zone1)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
# Passer la valeur suivante à TRUE pour reproduire les extractions.
knitr::opts_chunk$set(eval = FALSE)
knitr::opts_chunk$set(warning = FALSE)
